
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>9.3. Graph Matching &#8212; Hands-on Network Machine Learning with Scikit-Learn and Graspologic</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet">
  <link href="../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script >let toggleHintShow = 'Click to show';</script>
    <script >let toggleHintHide = 'Click to hide';</script>
    <script >let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script >const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"processClass": "tex2jax_process|mathjax_process|math|output_area"}})</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="9.4. Vertex Nomination For Two Networks" href="multiple-vertex-nomination.html" />
    <link rel="prev" title="9.2. Differences in Block Matrices" href="significant-communities.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Hands-on Network Machine Learning with Scikit-Learn and Graspologic</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../coverpage.html">
   Hands-on Network Machine Learning with Scikit-Learn and Graspologic
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../introduction/preface.html">
   Preface
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../introduction/terminology.html">
   Terminology and Math Refresher
  </a>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Foundations
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../foundations/ch1/ch1.html">
   1. The Network Machine Learning Landscape
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch1/what-is-a-network.html">
     1.1. What Is A Network?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch1/why-study-networks.html">
     1.2. Why Study Networks?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch1/examples-of-applications.html">
     1.3. Examples of applications
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch1/types-of-learning-probs.html">
     1.4. Approaches for Network Learning Problems
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../foundations/ch2/ch2.html">
   2. End-to-end Biology Network Machine Learning Project
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch2/big-picture.html">
     2.1. Look at the big picture
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch2/get-the-data.html">
     2.2. Get the Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch2/prepare-the-data.html">
     2.3. Prepare the Data for Network Algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch2/discover-and-visualize.html">
     2.4. Discover and Visualize the Data to Gain Insights
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../foundations/ch3/ch3.html">
   3. End-to-end Business Network Machine Learning Project
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch3/big-picture.html">
     3.1. Look at the Big Picture
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch3/get-the-data.html">
     3.2. Get the Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch3/discover-and-visualize.html">
     3.3. Discover and Visualize the Data to Gain Insights
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch3/prepare-the-data.html">
     3.4. Prepare the Data for Network Algorithms
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Representations
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../representations/ch4/ch4.html">
   4. Properties of Networks as a Statistical Object
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch4/matrix-representations.html">
     4.1. Matrix Representations Of Networks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch4/properties-of-networks.html">
     4.2. Properties of Networks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch4/network-representations.html">
     4.3. Representations of Networks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch4/regularization.html">
     4.4. Regularization
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../representations/ch5/ch5.html">
   5. Why Use Statistical Models?
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch5/why-use-models.html">
     5.1. Why Use Statistical Models?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch5/single-network-models_ER.html">
     5.2. Erdös-Rényi (ER) Random Networks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch5/single-network-models_SBM.html">
     5.3. Stochastic Block Models (SBM)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch5/single-network-models_RDPG.html">
     5.4. Random Dot Product Graphs (RDPG)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch5/single-network-models_IER.html">
     5.5. Inhomogeneous Erdos Renyi (IER) Random Network Model
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch5/multi-network-models.html">
     5.6. Multiple Network Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch5/models-with-covariates.html">
     5.7. Network Models with Covariates
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../representations/ch6/ch6.html">
   6. Learning Network Representations
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch6/estimating-parameters_mle.html">
     6.1. Estimating Parameters in Network Models via MLE
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch6/why-embed-networks.html">
     6.2. Why embed networks?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch6/spectral-embedding.html">
     6.3. Spectral Embedding Methods
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch6/estimating-parameters_spectral.html">
     6.4. Estimating Parameters for the RDPG
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch6/random-walk-diffusion-methods.html">
     6.5. Random walk and diffusion-based methods
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch6/graph-neural-networks.html">
     6.6. Graph Neural Networks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch6/multigraph-representation-learning.html">
     6.7. Multiple-Network Representation Learning
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch6/joint-representation-learning.html">
     6.8. Joint Representation Learning
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../representations/ch7/ch7.html">
   7. Theoretical Results
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch7/theory-single-network.html">
     7.1. Theory for Network Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch7/theory-multigraph.html">
     7.2. Maximum Likelihood Estimate Theory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch7/theory-matching.html">
     7.3. Spectral Method Theory
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Applications
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch8/ch8.html">
   8. Applications When You Have One Network
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch8/community-detection.html">
     8.1. Community Detection
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch8/testing-differences.html">
     8.2. Testing for Differences between Groups of Edges
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch8/model-selection.html">
     8.3. Model Selection
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch8/single-vertex-nomination.html">
     8.4. Single-Network Vertex Nomination
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch8/out-of-sample.html">
     8.5. Out-of-sample Embedding
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="ch9.html">
   9. Applications for Two Networks
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
  <label for="toctree-checkbox-9">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="two-sample-hypothesis.html">
     9.1. Latent Two-Sample Hypothesis Testing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="significant-communities.html">
     9.2. Differences in Block Matrices
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     9.3. Graph Matching
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="multiple-vertex-nomination.html">
     9.4. Vertex Nomination For Two Networks
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch10/ch10.html">
   10. Applications for Many Networks
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch10/anomaly-detection.html">
     10.1. Anomaly Detection For Timeseries of Networks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch10/significant-edges.html">
     10.2. Testing for Significant Edges
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch10/significant-vertices.html">
     10.3. Testing for Significant Vertices
    </a>
   </li>
  </ul>
 </li>
</ul>
<p class="caption">
 <span class="caption-text">
  Reference
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference external" href="https://graspologic.readthedocs.io/en/latest/">
   Graspologic Documentation
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/applications/ch9/graph-matching-vertex.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/neurodata/graph-stats-book"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/neurodata/graph-stats-book/issues/new?title=Issue%20on%20page%20%2Fapplications/ch9/graph-matching-vertex.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        <a class="edit-button" href="https://github.com/neurodata/graph-stats-book/edit/master/network_machine_learning_in_python/applications/ch9/graph-matching-vertex.ipynb"><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Edit this page"><i class="fas fa-pencil-alt"></i>suggest edit</button></a>
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#graph-matching-small-networks">
   9.3.1. Graph Matching Small Networks
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#permutation-matrices">
   9.3.2. Permutation Matrices
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     9.3.2.1. Permutation matrices
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#pb-moves-the-rows">
       9.3.2.1.1.
       <span class="math notranslate nohighlight">
        \(PB\)
       </span>
       moves the rows
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#cp-top-moves-the-columns">
     9.3.2.2.
     <span class="math notranslate nohighlight">
      \(CP^\top\)
     </span>
     moves the columns
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pdp-top-moves-the-rows-and-columns-concurrently">
     9.3.2.3.
     <span class="math notranslate nohighlight">
      \(PDP^\top\)
     </span>
     moves the rows and columns concurrently
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#using-concurrent-row-and-column-permutations-on-adjacency-matrices">
     9.3.2.4. Using concurrent row and column permutations on adjacency matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#permutation-matrices-to-match-network">
     9.3.2.5. Permutation Matrices to Match Network
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#finding-an-good-permutation-with-gradient-descent-optimization">
   9.3.3. Finding an Good Permutation with Gradient Descent Optimization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#graph-matching-with-graspologic">
   9.3.4. Graph Matching with graspologic
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#seeds">
     9.3.4.1. Seeds
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#seeded-graph-matching-on-correlated-network-pairs">
   9.3.5. Seeded Graph Matching on Correlated Network Pairs
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unshuffling-network-2-without-seeds">
     9.3.5.1. Unshuffling network 2 without seeds
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unshuffling-network-2-with-10-seeds">
     9.3.5.2. Unshuffling network 2 with 10 seeds
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#what-happens-when-the-number-of-nodes-aren-t-the-same">
   9.3.6. What happens when the number of nodes aren’t the same?
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#naive-padded-graph-matching">
     9.3.6.1. Naive Padded Graph Matching
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#adopted-padded-graph-matching">
     9.3.6.2. Adopted Padded Graph Matching
    </a>
   </li>
  </ul>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Graph Matching</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#graph-matching-small-networks">
   9.3.1. Graph Matching Small Networks
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#permutation-matrices">
   9.3.2. Permutation Matrices
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id1">
     9.3.2.1. Permutation matrices
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#pb-moves-the-rows">
       9.3.2.1.1.
       <span class="math notranslate nohighlight">
        \(PB\)
       </span>
       moves the rows
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#cp-top-moves-the-columns">
     9.3.2.2.
     <span class="math notranslate nohighlight">
      \(CP^\top\)
     </span>
     moves the columns
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#pdp-top-moves-the-rows-and-columns-concurrently">
     9.3.2.3.
     <span class="math notranslate nohighlight">
      \(PDP^\top\)
     </span>
     moves the rows and columns concurrently
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#using-concurrent-row-and-column-permutations-on-adjacency-matrices">
     9.3.2.4. Using concurrent row and column permutations on adjacency matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#permutation-matrices-to-match-network">
     9.3.2.5. Permutation Matrices to Match Network
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#finding-an-good-permutation-with-gradient-descent-optimization">
   9.3.3. Finding an Good Permutation with Gradient Descent Optimization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#graph-matching-with-graspologic">
   9.3.4. Graph Matching with graspologic
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#seeds">
     9.3.4.1. Seeds
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#seeded-graph-matching-on-correlated-network-pairs">
   9.3.5. Seeded Graph Matching on Correlated Network Pairs
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unshuffling-network-2-without-seeds">
     9.3.5.1. Unshuffling network 2 without seeds
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unshuffling-network-2-with-10-seeds">
     9.3.5.2. Unshuffling network 2 with 10 seeds
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#what-happens-when-the-number-of-nodes-aren-t-the-same">
   9.3.6. What happens when the number of nodes aren’t the same?
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#naive-padded-graph-matching">
     9.3.6.1. Naive Padded Graph Matching
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#adopted-padded-graph-matching">
     9.3.6.2. Adopted Padded Graph Matching
    </a>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="graph-matching">
<h1><span class="section-number">9.3. </span>Graph Matching<a class="headerlink" href="#graph-matching" title="Permalink to this headline">¶</a></h1>
<p>You work at Facebook and Twitter, but there’s been a terrible incident on the Twitter end. All Twitter users’ names and handles have been somehow been deleted! Your bosses are furious and have tasked you with somehow recovering the lost information. How might you go about doing this? Luckily, you’ve been working hard and have somehow earned yourself this dual Facebook/Twitter gig, so you have a great resource at your disposal: the Facebook social network. You know all facebook users and who they are friends with, and since you’ve only lost the twitter usernames, you can still figure out which unnamed twitter users follow each other. You decide to use the Facebook network connectivity data to re-label the twitter social network. Alternatively, you can say the we are “aligning” Twitter based on Facebook.</p>
<p>In the two social networks above, each user is a node and an edge exists if two users are friends. We’ll define the facebook and twitter networks as <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(T\)</span> respectively, with associated adjacency matrices <span class="math notranslate nohighlight">\(A_F\)</span> and <span class="math notranslate nohighlight">\(A_T\)</span>. Aligning the nodes of two networks is known as <em>Graph Matching</em>, because we are matching the node indices of one network (or, <em>graph</em>) to another. This can also be thought of as a mapping; that is, based on the neighbors of a node in <span class="math notranslate nohighlight">\(F\)</span>, you find a node in <span class="math notranslate nohighlight">\(T\)</span> with the most similar neighborhood structure, then give the two nodes the same index. In other words, one of our Twitter users will be assigned the user name of the Facebook user with the most connections in common. This is done for the whole network, with the end result being that overall the structure is best preserved.</p>
<p>There are a ton of ways to match the nodes of two networks. In fact, for network pairs with <span class="math notranslate nohighlight">\(n\)</span> nodes, there are <span class="math notranslate nohighlight">\(n!\)</span> possible mappings; for example, when <span class="math notranslate nohighlight">\(n=100\)</span>, there are more than <span class="math notranslate nohighlight">\(10^{157}\)</span> possible matchings. So how would we go about figuring out which mapping is best without the computationally gargantuan task of checking each one? First, we need a metric that tells us how similar two networks are to each other. For graph matching, this similarity metric is defined as <span class="math notranslate nohighlight">\(f(A, B) = ||A - B||_F^2\)</span> for unweighted adjacency matrices <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>. This quantity is known as the squared <em>Frobenius norm</em> (hence the subscript <span class="math notranslate nohighlight">\(F\)</span>) of the difference between <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>. In other words, <span class="math notranslate nohighlight">\(f(A, B)\)</span> is the sum of the squared elementwise differences between <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>, or the quantity:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
    f(A, B) &amp;= ||A - B||_F^2 = \sum_{i, j}(a_{ij} - b_{ij})^2
\end{align*}\]</div>
<p>To understand this functionally, consider the best possible case where where the two networks (here they are two triangles) are identical: <span class="math notranslate nohighlight">\(A=B\)</span>.</p>
<div class="math">
\[
A = 
\begin{array}{cc} &
\begin{array}{ccc} 0 & 1 & 2 \end{array}
\\
\begin{array}{ccc}
0 \\
1 \\
2 \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 1\\
1 & 0 & 1\\
1 & 1 & 0\end{array}
\right)\end{array}
\quad \quad
B = 
\begin{array}{cc} &
\begin{array}{ccc} 0 & 1 & 2 \end{array}
\\
\begin{array}{ccc}
0 \\
1 \\
2 \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 1\\
1 & 0 & 1\\
1 & 1 & 0\end{array}
\right)\end{array}
\\
A-B =
\begin{array}{cc} &
\begin{array}{ccc} 0 & 1 & 2 \end{array}
\\
\begin{array}{ccc}
0 \\
1 \\
2 \end{array}
&
\left(
\begin{array}{ccc}
0 & 0 & 0\\
0 & 0 & 0\\
0 & 0 & 0\end{array}
\right)\end{array}
\\
||A - B||_F^2 = 0
\]
    </div>
As we seen above, the difference will be a matrix of all zeros, and taking the squared Frobenius norm will then yield $f(A,B) = 0$. This is because all of the element-wise differences $a_{ij} - b_{ij}$ are just zero, and hence both their square (and sum) will also be zero. Below we remove one edge from $B$,
<div class="math">
\[
A = 
\begin{array}{cc} &
\begin{array}{ccc} 0 & 1 & 2 \end{array}
\\
\begin{array}{ccc}
0 \\
1 \\
2 \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 1\\
1 & 0 & 1\\
1 & 1 & 0\end{array}
\right)\end{array}
\quad \quad
B = 
\begin{array}{cc} &
\begin{array}{ccc} 0 & 1 & 2 \end{array}
\\
\begin{array}{ccc}
0 \\
1 \\
2 \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 1\\
1 & 0 & 0\\
1 & 0 & 0\end{array}
\right)\end{array}
\\
A-B =
\begin{array}{cc} &
\begin{array}{ccc} 0 & 1 & 2 \end{array}
\\
\begin{array}{ccc}
0 \\
1 \\
2 \end{array}
&
\left(
\begin{array}{ccc}
0 & 0 & 0\\
0 & 0 & 1\\
0 & 1 & 0\end{array}
\right)\end{array}
\\
||A - B||_F^2 = 2
\]
    </div>
<p>then <span class="math notranslate nohighlight">\(f(A,B) = 2\)</span>. If we consider the worst possible case (every edge in <span class="math notranslate nohighlight">\(A\)</span> does not exist in <span class="math notranslate nohighlight">\(B\)</span>),</p>
<div class="math">
\[
A = 
\begin{array}{cc} &
\begin{array}{ccc} 0 & 1 & 2 \end{array}
\\
\begin{array}{ccc}
0 \\
1 \\
2 \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 1\\
1 & 0 & 1\\
1 & 1 & 0\end{array}
\right)\end{array}
\quad \quad
B = 
\begin{array}{cc} &
\begin{array}{ccc} 0 & 1 & 2 \end{array}
\\
\begin{array}{ccc}
0 \\
1 \\
2 \end{array}
&
\left(
\begin{array}{ccc}
0 & 0 & 0\\
0 & 0 & 0\\
0 & 0 & 0\end{array}
\right)\end{array}
\\
A-B =
\begin{array}{cc} &
\begin{array}{ccc} 0 & 1 & 2 \end{array}
\\
\begin{array}{ccc}
0 \\
1 \\
2 \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 1\\
1 & 0 & 1\\
1 & 1 & 0\end{array}
\right)\end{array}
\\
||A - B||_F^2 = 6
\]
    </div>
then $f(A,B) = n(n - 1) = 3\cdot 2 = 6$. In this sense, the metric effectively counts the total number of disagreements in the adjacency matrices between $A$ and $B$. Thus, we want to find the mapping where $f(A, B)$ is as small as possible.
<div class="section" id="graph-matching-small-networks">
<h2><span class="section-number">9.3.1. </span>Graph Matching Small Networks<a class="headerlink" href="#graph-matching-small-networks" title="Permalink to this headline">¶</a></h2>
<p>Say we have the network pairs below, <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(F\)</span>. They have four nodes each, <span class="math notranslate nohighlight">\(\{1, 2, 3, 4\}\)</span> for <span class="math notranslate nohighlight">\(T\)</span>, and <span class="math notranslate nohighlight">\(\{a, b, c, d\}\)</span> for <span class="math notranslate nohighlight">\(F\)</span>. In this case, the nodes represent people within the social networks, and the edges represent whether two people are connected on the social networking site. In this case, we will assume we have a node correspondance:</p>
<ol class="simple">
<li><p>Person <span class="math notranslate nohighlight">\(0\)</span> on Twitter is person <span class="math notranslate nohighlight">\(a\)</span> on Facebook,</p></li>
<li><p>Person <span class="math notranslate nohighlight">\(1\)</span> on Twitter is person <span class="math notranslate nohighlight">\(b\)</span> on Facebook,</p></li>
<li><p>Person <span class="math notranslate nohighlight">\(2\)</span> on Twitter is person <span class="math notranslate nohighlight">\(c\)</span> on Facebook,</p></li>
<li><p>Person <span class="math notranslate nohighlight">\(3\)</span> on Twitter is person <span class="math notranslate nohighlight">\(d\)</span> on Facebook.
The corresponding adjacency matrices of the two networks are equal to each other when the nodes are laid out for <span class="math notranslate nohighlight">\(A_T\)</span> as <span class="math notranslate nohighlight">\(\{0, 1, 2, 3\}\)</span>, and when the nodes are laid out for <span class="math notranslate nohighlight">\(A_F\)</span> as <span class="math notranslate nohighlight">\(\{a,b,c,d\}\)</span>.</p></li>
</ol>
<p><img alt="gm_11" src="../../_images/gm_1.png" /></p>
<div class="math">
\[
A_T = 
\begin{array}{cc} &
\begin{array}{cccc} 0 & 1 & 2 & 3 \end{array}
\\
\begin{array}{cccc}
0 \\
1 \\
2 \\
3 \end{array}
&
\left(
\begin{array}{cccc}
0 & 1 & 1 & 0\\
1 & 0 & 0 & 1\\
1 & 0 & 0 & 1\\
0 & 1 & 1 & 0\end{array}
\right)\end{array}
\quad \quad
A_F = 
\begin{array}{cc} &
\begin{array}{cccc} a & b & c & d \end{array}
\\
\begin{array}{ccc}
a \\
b \\
c \\
d \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 1 & 0\\
1 & 0 & 0 & 1\\
1 & 0 & 0 & 1\\
0 & 1 & 1 & 0\end{array}
\right)\end{array} \\
|A_T - A_F| = \left(
\begin{array}{ccc}
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\end{array}
\right)
\]
    </div>
And as we learned above, therefore $f(A_T, A_B) = 0$. As we can see, when we compare the networks with the nodes ordered correctly (Person $1$ Twitter is the first node, Person $a$ from Facebook is its first node, Person $2$ from Twitter is the first node of $A_T$, Person $b$ from Facebook is the second node of $A_F$, so on and so forth). What we've done here by ordering the nodes in such tuples is implicitly made the statement that, there is something similar about the nodes $j$ between Twitter and Facebook, and therefore, ordering the adjacency matrices while obeying this similarity is going to give us a *low* edge disagreement (here, just zero). 
<p>We can see this easily, by considering what happens if we reorder the nodes <em>simultaneously</em> for each network. Let’s instead order the nodes for Twitter and Facebook as <span class="math notranslate nohighlight">\(\{2, 0, 1, 3\}\)</span> and <span class="math notranslate nohighlight">\(\{c, a, b, d\}\)</span>, respectively. We will call these new adjacency matrices with the new node ordering <span class="math notranslate nohighlight">\(A_T''\)</span> and <span class="math notranslate nohighlight">\(A_F''\)</span> respectively:</p>
<div class="math">
\[
A_T = 
\begin{array}{cc} &
\begin{array}{cccc} 2 & 0 & 1 & 3 \end{array}
\\
\begin{array}{cccc}
2 \\
0 \\
1 \\
3 \end{array}
&
\left(
\begin{array}{cccc}
0 & 1 & 0 & 1 \\
1 & 0 & 1 & 0\\
0 & 1 & 0 & 1\\
1 & 0 & 1 & 0
\end{array}
\right)\end{array}
\quad \quad
A_F = 
\begin{array}{cc} &
\begin{array}{cccc} c & a & b & d \end{array}
\\
\begin{array}{ccc}
c \\
a \\
b \\
d \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 0 & 1 \\
1 & 0 & 1 & 0\\
0 & 1 & 0 & 1\\
1 & 0 & 1 & 0
\end{array}
\right)\end{array} \\
|A_T - A_F| = \left(
\begin{array}{ccc}
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\end{array}
\right)
\]
    </div>
<p>The idea is that, even though the ordering of the nodes is different, we have maintained that <em>like goes with like</em>: the first node for Twitter is node <span class="math notranslate nohighlight">\(2\)</span> and the first node for Facebook is node <span class="math notranslate nohighlight">\(c\)</span>, the second node for Twitter is <span class="math notranslate nohighlight">\(0\)</span> and the second node for Facebook is node <span class="math notranslate nohighlight">\(a\)</span>, so on and so forth. The node orderings preserve the <em>correspondance</em> between the nodes of Twitter with the nodes of Facebook.</p>
<p>Unfortunately, nothing in life nor network machine learning is ever this simple. The spatial layout of a network’s nodes is arbirary, and in reality it can often be much harder to tell whether two networks are the same. For graph matching, we don’t actually <em>know</em> the node correspondance between the two networks: we have no idea that person <span class="math notranslate nohighlight">\(0\)</span> on Twitter is person <span class="math notranslate nohighlight">\(a\)</span> on Facebook, person <span class="math notranslate nohighlight">\(1\)</span> on Twitter is person <span class="math notranslate nohighlight">\(b\)</span> on Facebook, so on and so forth.</p>
<p>For instance, we can swap the spatial location of nodes <span class="math notranslate nohighlight">\(c\)</span> and <span class="math notranslate nohighlight">\(d\)</span> in network <span class="math notranslate nohighlight">\(F\)</span>, as shown below. Even with such a small network, it’s hard to tell whether the networks are the same.</p>
<p><img alt="gm_22" src="../../_images/gm_2.png" /></p>
<p>Further, let’s say we just had an arbitrary ordering of the nodes for Facebook, which is now a little bit different from the one which we just saw. Let’s imagine we have the nodes ordered instead as <span class="math notranslate nohighlight">\(\{a, b, d, c\}\)</span> instead of <span class="math notranslate nohighlight">\(\{a, b, c, d\}\)</span>, like we did before, but Twitter’s nodes are still ordered as <span class="math notranslate nohighlight">\(\{0, 1, 2, 3\}\)</span>. Now, the adjacency matrices won’t be equal either, where we use <span class="math notranslate nohighlight">\(A_F'\)</span> to denote the adjacency matrix for the Facebook network with this new node ordering:</p>
<div class="math">
\[
A_T = 
\begin{array}{cc} &
\begin{array}{cccc} 0 & 1 & 2 & 3 \end{array}
\\
\begin{array}{cccc}
0 \\
1 \\
2 \\
3 \end{array}
&
\left(
\begin{array}{cccc}
0 & 1 & 1 & 0\\
1 & 0 & 0 & 1\\
1 & 0 & 0 & 1\\
0 & 1 & 1 & 0\end{array}
\right)\end{array}
\quad \quad
A_F' = 
\begin{array}{cc} &
\begin{array}{cccc} a & b & d & c \end{array}
\\
\begin{array}{ccc}
a \\
b \\
d \\
c \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 0 & 1\\
1 & 0 & 1 & 0\\
0 & 1 & 0 & 1\\
1 & 0 & 1 & 0\end{array}
\right)\end{array} \\
|A_T - A_F'| = \left(
\begin{array}{ccc}
0 & 0 & 1 & 1\\
0 & 0 & 1 & 1\\
1 & 1 & 0 & 0\\
1 & 1 & 0 & 0\end{array}
\right)
\]
    </div>
and we get that $f(A_T, A_F') = 8$, since there are $8$ entries which are different in the adjacency matrices between $A_T$ and $A_F$. This might seem a bit high, but note that because the network is undirected, adjecency disagreements are effectively counted twice (a single edge disagreement for an edge $(i,j)$ also yield a difference for edge $(j, i)$, since the adjacency matrix is symmetric). By comparing the nodes of Twitter and Facebook with the nodes *misaligned*, we have effectively *broken* the node correspondance between the nodes of Twitter and Facebook. 
<p>In this sense, we can see how networks with a low number of edge disagreements might be considered to be better <em>matches</em> in terms of the node correspondance. When the nodes are <em>aligned</em> in a way which respects the node correspondance, identical networks have a low number of disagreements, and when the nodes are <em>aligned</em> in a way which disregards the node correspodance, the networks have a high number of disagreements. We will build upon this idea further, by exploring how to manipulate our adjacency matrices such that we can find alignments that match well. You can do this using something called a permutation matrix.</p>
</div>
<div class="section" id="permutation-matrices">
<h2><span class="section-number">9.3.2. </span>Permutation Matrices<a class="headerlink" href="#permutation-matrices" title="Permalink to this headline">¶</a></h2>
<p>Permutation matrices are used to shuffle around the rows and columns of other matrices. A permutation matrix is a matrix of all ones and zeros, where each row and column adds up to one. In other words, each row has exactly one entry equal to one, with the rest being zeros; the same is true for the columns.</p>
<div class="section" id="id1">
<h3><span class="section-number">9.3.2.1. </span>Permutation matrices<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Permutation matrices are commonly used as a method to move around the rows and columns of a square matrix. A <strong>permutation matrix</strong> is a matrix where, for every row and column, exactly one entry has a value of one.</p>
<div class="section" id="pb-moves-the-rows">
<h4><span class="section-number">9.3.2.1.1. </span><span class="math notranslate nohighlight">\(PB\)</span> moves the rows<a class="headerlink" href="#pb-moves-the-rows" title="Permalink to this headline">¶</a></h4>
<p>Let’s consider a matrix <span class="math notranslate nohighlight">\(B\)</span> where all entries of the first row have a value of one, all entries of the second row have a value of two, all entries of the third row have a value of three, and all entries of the fourth row have a value of four. We can apply a permutation matrix <span class="math notranslate nohighlight">\(P\)</span> to swap the rows around with the following heuristic. If the matrix <span class="math notranslate nohighlight">\(P\)</span> has an entry <span class="math notranslate nohighlight">\(p_{ij}\)</span> which is one, then in the resulting matrix, the row <span class="math notranslate nohighlight">\(i\)</span> will be the row <span class="math notranslate nohighlight">\(j\)</span> from the matrix we permuted.</p>
<p>For instance, in the following example, the values <span class="math notranslate nohighlight">\(p_{12}\)</span>, <span class="math notranslate nohighlight">\(p_{23}\)</span>, <span class="math notranslate nohighlight">\(p_{34}\)</span>, and <span class="math notranslate nohighlight">\(p_{41}\)</span> all have values of one, which means we will reorder the rows of <span class="math notranslate nohighlight">\(B\)</span> so that <span class="math notranslate nohighlight">\(PB\)</span> will have the top row being the second row from the original matrix (and will have a value of two), the second row will be the third row from the original matrix (and will have a value of three), the third row will be the fourth row from the original matrix (and will have a value of four), and the fourth row will be the first row from the original matrix (and will have a value of one.</p>
<p>We apply this “row” permutation with the matrix multiplication <span class="math notranslate nohighlight">\(PB\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>

<span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="c1"># P * B</span>
<span class="n">PB</span> <span class="o">=</span> <span class="n">P</span> <span class="o">@</span> <span class="n">B</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">graspologic.plot</span> <span class="kn">import</span> <span class="n">heatmap</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">graphbook_code</span> <span class="kn">import</span> <span class="n">cmaps</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">B</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">PB</span><span class="p">]</span>
<span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Original matrix $B$&quot;</span><span class="p">,</span> <span class="s2">&quot;Permutation Matrix $P$&quot;</span><span class="p">,</span> <span class="s2">&quot;Row Permutation $PB$&quot;</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">],</span> <span class="n">title</span> <span class="o">=</span> <span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Column&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Row&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph-matching-vertex_10_0.png" src="../../_images/graph-matching-vertex_10_0.png" />
</div>
</div>
</div>
</div>
<div class="section" id="cp-top-moves-the-columns">
<h3><span class="section-number">9.3.2.2. </span><span class="math notranslate nohighlight">\(CP^\top\)</span> moves the columns<a class="headerlink" href="#cp-top-moves-the-columns" title="Permalink to this headline">¶</a></h3>
<p>Likewise, a column permutation behaves very similarly. Let’s now consider a matrix <span class="math notranslate nohighlight">\(C\)</span>, where the first column has a value of one, the second column has a value of two, the third column has a value of three, and the fourth column has a value of four. We use the same permutation matrix, where here, <span class="math notranslate nohighlight">\(p_{ij}\)</span> indicates that column <span class="math notranslate nohighlight">\(i\)</span> of the new matrix will be column <span class="math notranslate nohighlight">\(j\)</span> from the matrix before the permutation was applied. We apply the column permutation matrix as <span class="math notranslate nohighlight">\(CP^\top\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>

<span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="c1"># C * P.T</span>
<span class="n">CPt</span> <span class="o">=</span> <span class="n">C</span> <span class="o">@</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">C</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">CPt</span><span class="p">]</span>
<span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Original matrix $C$&quot;</span><span class="p">,</span> <span class="s2">&quot;Permutation Matrix $P$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;Column Permutation $CP^\top$&quot;</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">],</span> <span class="n">title</span> <span class="o">=</span> <span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Column&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Row&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph-matching-vertex_13_0.png" src="../../_images/graph-matching-vertex_13_0.png" />
</div>
</div>
</div>
<div class="section" id="pdp-top-moves-the-rows-and-columns-concurrently">
<h3><span class="section-number">9.3.2.3. </span><span class="math notranslate nohighlight">\(PDP^\top\)</span> moves the rows and columns concurrently<a class="headerlink" href="#pdp-top-moves-the-rows-and-columns-concurrently" title="Permalink to this headline">¶</a></h3>
<p>As an interesting property of permutation matrices, we can apply these operations sequentially to reorder both the rows <em>and</em> columns of a matrix. Consider, for instance, a permutation matrix where row/column <span class="math notranslate nohighlight">\(1\)</span> of the original matrix becomes row/column <span class="math notranslate nohighlight">\(2\)</span> of the new matrix, and likewise, row/column <span class="math notranslate nohighlight">\(2\)</span> of the original matrix becomes row/column <span class="math notranslate nohighlight">\(1\)</span> of the new matrix. We’ll consider a matrix <span class="math notranslate nohighlight">\(D\)</span> where the first row and first column both have entries of all ones, and the rest of the matrix has the value zero. The original matrix and the permutation matrix look like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>

<span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">D</span><span class="p">,</span> <span class="n">P</span><span class="p">]</span>
<span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Original matrix $D$&quot;</span><span class="p">,</span> <span class="s2">&quot;Permutation Matrix $P$&quot;</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">],</span> <span class="n">title</span> <span class="o">=</span> <span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Column&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Row&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph-matching-vertex_16_0.png" src="../../_images/graph-matching-vertex_16_0.png" />
</div>
</div>
<p>So, looking at the permutation matrix, if we were to apply this as a row or column permutation, row/column 3 and 4 will stay the same (<span class="math notranslate nohighlight">\(p_{33} = 1\)</span> and <span class="math notranslate nohighlight">\(p_{44} = 1\)</span>, so row/column <span class="math notranslate nohighlight">\(3\)</span> and <span class="math notranslate nohighlight">\(4\)</span> will become row/column <span class="math notranslate nohighlight">\(3\)</span> and <span class="math notranslate nohighlight">\(4\)</span> respectively in the new representations), and row/column <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(2\)</span> would swap (row/column <span class="math notranslate nohighlight">\(1\)</span> would become row/column <span class="math notranslate nohighlight">\(2\)</span>, and vice versa). Let’s see what happens when we apply these sequentially:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PD</span> <span class="o">=</span> <span class="n">P</span> <span class="o">@</span> <span class="n">D</span>
<span class="n">PDPt</span> <span class="o">=</span> <span class="n">PD</span> <span class="o">@</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="mi">14</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">D</span><span class="p">,</span> <span class="n">PD</span><span class="p">,</span> <span class="n">PDPt</span><span class="p">]</span>
<span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Original matrix $D$&quot;</span><span class="p">,</span> <span class="s2">&quot;Permutate the rows $PD$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;Permute the rows then the columns $PDP^\top$&quot;</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">],</span> <span class="n">title</span> <span class="o">=</span> <span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Column&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Row&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph-matching-vertex_19_0.png" src="../../_images/graph-matching-vertex_19_0.png" />
</div>
</div>
<p>So, we take the original matrix, and first begin by swapping rows <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(2\)</span> to give us <span class="math notranslate nohighlight">\(PD\)</span>. Next, using this row-permuted matrix, we then permute the columns by swapping columns <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(2\)</span> of <span class="math notranslate nohighlight">\(PD\)</span>, to give us <span class="math notranslate nohighlight">\(PD^\top\)</span>. This shows that by using a permutation matrix to row and then column swap, we can reorder the rows and columns of <span class="math notranslate nohighlight">\(D\)</span> simultaneously.</p>
</div>
<div class="section" id="using-concurrent-row-and-column-permutations-on-adjacency-matrices">
<h3><span class="section-number">9.3.2.4. </span>Using concurrent row and column permutations on adjacency matrices<a class="headerlink" href="#using-concurrent-row-and-column-permutations-on-adjacency-matrices" title="Permalink to this headline">¶</a></h3>
<p>For our networks, remember that the adjacency matrix is the matrix <span class="math notranslate nohighlight">\(A\)</span> where the entry <span class="math notranslate nohighlight">\(a_{ij}\)</span> represents whether or not there is an edge between nodes <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>. The key aspect is that the indexing for the adjacency matrix, <span class="math notranslate nohighlight">\(ij\)</span>, is an indexing over a single set: the nodes. This means that if we want to <em>reorder</em> the adjacency matrix by moving around the nodes, we need to move both the rows <em>and</em> the columns concurrently, since the <em>node ordering</em> is what is being permuted. If we had a permutation of the nodes given by <span class="math notranslate nohighlight">\(P\)</span>, we would correspondingly reorder the adjacency matrix by permuting the rows <em>and</em>
columns of <span class="math notranslate nohighlight">\(A\)</span> by using <span class="math notranslate nohighlight">\(PAP^\top\)</span>.</p>
</div>
<div class="section" id="permutation-matrices-to-match-network">
<h3><span class="section-number">9.3.2.5. </span>Permutation Matrices to Match Network<a class="headerlink" href="#permutation-matrices-to-match-network" title="Permalink to this headline">¶</a></h3>
<p>Next, we again consider the previous simple network example from Twitter and Facebook networks. Remember that we had two networks, where there was a node correspondance in that person <span class="math notranslate nohighlight">\(0\)</span> from Twitter was the same as person <span class="math notranslate nohighlight">\(a\)</span> from Facebook, person <span class="math notranslate nohighlight">\(1\)</span> from Twitter was the same as the person <span class="math notranslate nohighlight">\(b\)</span> from Facebook, so on and so forth.</p>
<p>We will suppose that the ordering of the nodes from Twitter are given to us in order, <span class="math notranslate nohighlight">\(\{0, 1, 2, 3\}\)</span>, so in the ideal case, if the nodes from Facebook respect the node correspondance and the nodes are ordered <span class="math notranslate nohighlight">\(\{a, b, c, d\}\)</span>, we have that:</p>
<p><img alt="gm_11" src="../../_images/gm_1.png" /></p>
<div class="math">
\[
A_T = 
\begin{array}{cc} &
\begin{array}{cccc} 0 & 1 & 2 & 3 \end{array}
\\
\begin{array}{cccc}
0 \\
1 \\
2 \\
3 \end{array}
&
\left(
\begin{array}{cccc}
0 & 1 & 1 & 0\\
1 & 0 & 0 & 1\\
1 & 0 & 0 & 1\\
0 & 1 & 1 & 0\end{array}
\right)\end{array}
\quad \quad
A_F = 
\begin{array}{cc} &
\begin{array}{cccc} a & b & c & d \end{array}
\\
\begin{array}{ccc}
a \\
b \\
c \\
d \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 1 & 0\\
1 & 0 & 0 & 1\\
1 & 0 & 0 & 1\\
0 & 1 & 1 & 0\end{array}
\right)\end{array} \\
|A_T - A_F| = \left(
\begin{array}{ccc}
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\end{array}
\right)
\]
    </div>
and $f(A_T, A_F) = 0$.<p>However, if you remember, the problem was that we were <em>instead</em> given the nodes from Facebook in a different order; we were given the node ordering <span class="math notranslate nohighlight">\(\{a, b, d, c\}\)</span> with adjacency matrix <span class="math notranslate nohighlight">\(A_F'\)</span>, leading to:</p>
<div class="math">
\[
A_T = 
\begin{array}{cc} &
\begin{array}{cccc} 0 & 1 & 2 & 3 \end{array}
\\
\begin{array}{cccc}
0 \\
1 \\
2 \\
3 \end{array}
&
\left(
\begin{array}{cccc}
0 & 1 & 1 & 0\\
1 & 0 & 0 & 1\\
1 & 0 & 0 & 1\\
0 & 1 & 1 & 0\end{array}
\right)\end{array}
\quad \quad
A_F' = 
\begin{array}{cc} &
\begin{array}{cccc} a & b & d & c \end{array}
\\
\begin{array}{ccc}
a \\
b \\
d \\
c \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 0 & 1\\
1 & 0 & 1 & 0\\
0 & 1 & 0 & 1\\
1 & 0 & 1 & 0\end{array}
\right)\end{array} \\
|A_T - A_F'| = \left(
\begin{array}{ccc}
0 & 0 & 1 & 1\\
0 & 0 & 1 & 1\\
1 & 1 & 0 & 0\\
1 & 1 & 0 & 0\end{array}
\right)
\]
    </div>
<p>and <span class="math notranslate nohighlight">\(f(A_T, A_F') = 8\)</span>. What we want to do is construct a permutation matrix <span class="math notranslate nohighlight">\(P\)</span>, which will keep nodes <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> in the same order, but swap nodes <span class="math notranslate nohighlight">\(c\)</span> and <span class="math notranslate nohighlight">\(d\)</span> in the node ordering. We can do this using exactly the strategy we developed above:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">AT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="n">AFp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>

<span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>

<span class="n">PAFpPt</span> <span class="o">=</span> <span class="n">P</span> <span class="o">@</span> <span class="n">AFp</span> <span class="o">@</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>

<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">AT</span><span class="p">,</span> <span class="n">AFp</span><span class="p">,</span> <span class="n">PAFpPt</span><span class="p">]</span>
<span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;$A_T$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;$A_F&#39;$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;$A_F = PA_F&#39; P^\top$&quot;</span><span class="p">]</span>

<span class="n">node_odx</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">]]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Node&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Node&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">node_odx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">node_odx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph-matching-vertex_23_0.png" src="../../_images/graph-matching-vertex_23_0.png" />
</div>
</div>
<p>As shown in the code block above, using a properly chosen permutation matrix <span class="math notranslate nohighlight">\(P\)</span>, we are able to recover the node correspondance between the networks for Twitter and Facebook. We obtain that for this particular choice of <span class="math notranslate nohighlight">\(P\)</span>, that <span class="math notranslate nohighlight">\(f(A_T, PA_F'P^\top) = 0\)</span>.</p>
<p>In this way, we will use this intuition to formulate the graph matching problem. For any two adjacency matrices <span class="math notranslate nohighlight">\(A, B\)</span>, we seek to minimize the cost function <span class="math notranslate nohighlight">\(g(A,B,P) = || A - PBP^\intercal||_F^2\)</span> with the restriction that <span class="math notranslate nohighlight">\(P\)</span> is a permuation matrix. You will notice that this is the definition of the Frobenius norm of the difference between <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>, where you have now expanded <span class="math notranslate nohighlight">\(f\)</span> to the function <span class="math notranslate nohighlight">\(g\)</span> which includes a permutation of the rows and columns of <span class="math notranslate nohighlight">\(B\)</span>. This means that you want to figure out a way in which you can shuffle the rows and columns of <span class="math notranslate nohighlight">\(B\)</span>, such that it is as close as possible to <span class="math notranslate nohighlight">\(A\)</span>. In mathematics, the process of minimizing (or maximizing) a function based on a set of restrictions (called <em>constraints</em>) is known as <em>optimization</em>.</p>
</div>
</div>
<div class="section" id="finding-an-good-permutation-with-gradient-descent-optimization">
<h2><span class="section-number">9.3.3. </span>Finding an Good Permutation with Gradient Descent Optimization<a class="headerlink" href="#finding-an-good-permutation-with-gradient-descent-optimization" title="Permalink to this headline">¶</a></h2>
<p>The algorithm used for solving graph matching optimization problem we described above is a variation of gradient descent.  The specifics of the algorithm are beyond the scope of this book, but for now you can simply imagine it as gradient descent. A gradient can be thought of as a vector valued slope; it is simply the slope of a function in all of it’s dimensions, at a single point in space. Gradient Descent is a very common optimization method using to find optimal solutions for a wide range of problems.</p>
<p>A simple way to think of the method is gravity.  Consider an inspector using a golf ball to find the lowest point when installing a drain. The ball rolls down hill until it comes to a stop; once it stops, we know we’ve found the lowest point. Gradient descent works in a similar way, taking steps in the direction of the local gradient with respect to some parameter. Once the gradient is zero, a local minimum has been found and the algorithm is stopped.</p>
<p>The main steps of a gradient descent method are choosing a suitable initial position (can be chosen randomly), then gradually improving the cost function one step at a time, until the function is changing by a very small amount, converging to a minimum. The main issue with gradient descent is that it does not guarantee that you will find a global minimum, only that you will find the local minimum of your initial position.</p>
<p><img alt="grad_desc" src="../../_images/grad_desc.png" /></p>
<p>The image above is a simplification in two dimensions; the network functions we optimize over are n dimensional when matching networks with n nodes, making the problem incredibly difficult to solve. For this reason (among others outside of the scope of this book), the state-of-the-art graph matching algorithm is an approximation algorithm.</p>
</div>
<div class="section" id="graph-matching-with-graspologic">
<h2><span class="section-number">9.3.4. </span>Graph Matching with graspologic<a class="headerlink" href="#graph-matching-with-graspologic" title="Permalink to this headline">¶</a></h2>
<p>For the example below, we will match two networks with a known node mapping that preserves a common network structure. To do this, we simulate a single Erdos-Reyni network, <span class="math notranslate nohighlight">\(A\)</span>, with six nodes and an edge probability of 0.5. Then, we generate <span class="math notranslate nohighlight">\(B\)</span> by randomly permuting the node labels of <span class="math notranslate nohighlight">\(A\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">graspologic.simulations</span> <span class="kn">import</span> <span class="n">er_np</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">p</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="c1"># np.random.seed(1)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">er_np</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
<span class="n">node_shuffle_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">node_shuffle_input</span><span class="p">][:,</span> <span class="n">node_shuffle_input</span><span class="p">]</span>
<span class="n">disagreements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of adjecnecy disagreements: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements</span><span class="p">)))</span>

<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;$A$, a realization of $ER_6(0.5)$&#39;</span><span class="p">,</span> <span class="s1">&#39;$B$ ($A$ with the nodes randomly shuffled)&#39;</span><span class="p">]</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>
<span class="n">nodeAnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
<span class="n">nodenames</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodeAnames</span><span class="p">,</span> <span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">node_shuffle_input</span><span class="p">]]</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">xticklabels</span><span class="o">=</span><span class="n">nodenames</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">],</span>
            <span class="n">yticklabels</span><span class="o">=</span><span class="n">nodenames</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Node&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Node&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of adjecnecy disagreements: 16
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_30_1.png" src="../../_images/graph-matching-vertex_30_1.png" />
</div>
</div>
<p>Below, we create a model to solve the Graph Matching Problem using the <code class="docutils literal notranslate"><span class="pre">GraphMatch</span></code> class. The model is then fit for the two networks A and B.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">graspologic.match</span> <span class="kn">import</span> <span class="n">GraphMatch</span>

<span class="n">gmp</span> <span class="o">=</span> <span class="n">GraphMatch</span><span class="p">()</span>
<span class="n">gmp</span> <span class="o">=</span> <span class="n">gmp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
<span class="n">PBPt</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">gmp</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">][:,</span> <span class="n">gmp</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">]</span>
<span class="n">disagreements_after</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">PBPt</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="n">new_nodeodx</span> <span class="o">=</span> <span class="n">node_shuffle_input</span><span class="p">[</span><span class="n">gmp</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of adjacency disagreements: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements_after</span><span class="p">)))</span>


<span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;$A$&quot;</span><span class="p">,</span> <span class="s2">&quot;$B$ ($A$ shuffled)&quot;</span><span class="p">,</span> <span class="s2">&quot;$PBP^</span><span class="se">\\</span><span class="s2">top$, $B$ with nodes unsuffled&quot;</span><span class="p">,</span> <span class="s2">&quot;$|A - PBP^</span><span class="se">\\</span><span class="s2">top|$&quot;</span><span class="p">]</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="n">nodenames</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodeAnames</span><span class="p">,</span> <span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">node_shuffle_input</span><span class="p">],</span> <span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">new_nodeodx</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodeAnames</span><span class="p">]]</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">PBPt</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">PBPt</span><span class="p">)]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">xticklabels</span><span class="o">=</span><span class="n">nodenames</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">],</span> <span class="n">yticklabels</span><span class="o">=</span><span class="n">nodenames</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> 
            <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Node&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Node&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of adjacency disagreements: 8
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_33_1.png" src="../../_images/graph-matching-vertex_33_1.png" />
</div>
</div>
<p>The graph matching algorithm is able to successfully unshuffle <span class="math notranslate nohighlight">\(B\)</span>, with zero adjacency disagreements between <span class="math notranslate nohighlight">\(A\)</span> and the matched <span class="math notranslate nohighlight">\(B\)</span>.</p>
<div class="section" id="seeds">
<h3><span class="section-number">9.3.4.1. </span>Seeds<a class="headerlink" href="#seeds" title="Permalink to this headline">¶</a></h3>
<p>As mentioned previously, as networks become larger, they quickly become more difficult to match. One method to mitigate this difficulty is to use <span class="math notranslate nohighlight">\(\textit{seeds}\)</span>. Seeds are a subset of matches that we already know before we perform the graph matching. For example, if we are given two networks <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(F\)</span> with 300 nodes each, we might already know ten node matches between <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(F\)</span>. Having this prior information greatly improves our ability to match the networks.</p>
</div>
</div>
<div class="section" id="seeded-graph-matching-on-correlated-network-pairs">
<h2><span class="section-number">9.3.5. </span>Seeded Graph Matching on Correlated Network Pairs<a class="headerlink" href="#seeded-graph-matching-on-correlated-network-pairs" title="Permalink to this headline">¶</a></h2>
<p>To demonstrate the effectiveness of Seeded Graph Matching (<code class="docutils literal notranslate"><span class="pre">SGM</span></code>), the algorithm will be applied on a pair of correlated SBM networks (undirected, no self loops), which is a simpler adaptation of the <span class="math notranslate nohighlight">\(\rho\)</span>-correlated <span class="math notranslate nohighlight">\(RDPG\)</span> which we learned about in <a class="reference external" href="#link?">Chapter 5</a>. Like the <span class="math notranslate nohighlight">\(\rho\)</span>-correlated <span class="math notranslate nohighlight">\(RDPG\)</span>, the idea here is that we have two normal SBMs, but for any edge in the two networks <span class="math notranslate nohighlight">\(\mathbf a_{ij}^{(1)}\)</span> and <span class="math notranslate nohighlight">\(\mathbf a_{ij}^{(2)}\)</span>, they will be correlated with correlation <span class="math notranslate nohighlight">\(\rho\)</span>. In words, if <span class="math notranslate nohighlight">\(\rho\)</span> is positive, then if we know that <span class="math notranslate nohighlight">\(\mathbf a_{ij}^{(1)}\)</span> has a value of one, then we have information to suggest that <span class="math notranslate nohighlight">\(\mathbf a_{ij}^{(2)}\)</span> might be one too. In this case, we will have that <span class="math notranslate nohighlight">\(\mathbf A_1\)</span> and <span class="math notranslate nohighlight">\(\mathbf A_2\)</span> are <span class="math notranslate nohighlight">\(\rho-SBM_n(\vec z, B)\)</span> where the networks are highly correlated, and <span class="math notranslate nohighlight">\(\rho = 0.9\)</span>. The block matrix is:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
B &amp;= \begin{bmatrix} 
0.7 &amp; 0.3 &amp; 0.4\\
0.3 &amp; 0.7 &amp; 0.3\\
0.4 &amp; 0.3 &amp; 0.7
\end{bmatrix}
\end{align*}\]</div>
<p>The first <span class="math notranslate nohighlight">\(75\)</span> nodes in the network will be from community one, the second <span class="math notranslate nohighlight">\(75\)</span> nodes in the network will be from community two, and the third <span class="math notranslate nohighlight">\(75\)</span> nodes in the network will be from community three:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">graspologic.simulations</span> <span class="kn">import</span> <span class="n">er_corr</span><span class="p">,</span> <span class="n">sbm</span><span class="p">,</span> <span class="n">sbm_corr</span>
<span class="n">directed</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">loops</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">n_per_block</span> <span class="o">=</span> <span class="mi">75</span>
<span class="n">n_blocks</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">block_members</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">n_blocks</span> <span class="o">*</span> <span class="p">[</span><span class="n">n_per_block</span><span class="p">])</span>
<span class="n">n_verts</span> <span class="o">=</span> <span class="n">block_members</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="n">rho</span> <span class="o">=</span> <span class="mf">0.9</span>
<span class="n">block_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]])</span>

<span class="n">A1</span><span class="p">,</span> <span class="n">A2</span> <span class="o">=</span> <span class="n">sbm_corr</span><span class="p">(</span><span class="n">block_members</span><span class="p">,</span> <span class="n">block_probs</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="n">loops</span><span class="p">)</span>
<span class="n">disagreements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A1</span> <span class="o">-</span> <span class="n">A2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of adjacency disagreements: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements</span><span class="p">)))</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A1</span> <span class="o">-</span> <span class="n">A2</span><span class="p">)]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A^{(1)}$&quot;</span><span class="p">,</span> <span class="s2">&quot;Network $A^{(2)}$&quot;</span><span class="p">,</span> <span class="s2">&quot;$|A^{(1)} - A^{(2)}|$&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of adjacency disagreements: 2258
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_39_1.png" src="../../_images/graph-matching-vertex_39_1.png" />
</div>
</div>
<p>To emphasize the effectiveness of <code class="docutils literal notranslate"><span class="pre">SGM</span></code>, as well as why having seeds is important, we will randomly shuffle the vertices of network <span class="math notranslate nohighlight">\(A^{(2)}\)</span>. We will call this version of <span class="math notranslate nohighlight">\(A^{(2)}\)</span> after shuffling <span class="math notranslate nohighlight">\(A^{(2),s}\)</span>. This random permutation is stored, and unshuffled, such that we have available the optimal permutation that returns the original <span class="math notranslate nohighlight">\(A^{(2)}\)</span>.</p>
<p>Here we see that after shuffling network <span class="math notranslate nohighlight">\(A^{(2)}\)</span>, there are many more edge disagreements, as expected.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">node_shuffle_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">n_verts</span><span class="p">)</span>
<span class="n">A2_shuffled</span> <span class="o">=</span> <span class="n">A2</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">node_shuffle_input</span><span class="p">,</span> <span class="n">node_shuffle_input</span><span class="p">)]</span>
<span class="n">node_unshuffle_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_verts</span><span class="p">))</span>
<span class="n">node_unshuffle_input</span><span class="p">[</span><span class="n">node_shuffle_input</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_verts</span><span class="p">))</span>
<span class="n">disagreements_shuffled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A1</span> <span class="o">-</span> <span class="n">A2_shuffled</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of adjacency disagreements: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements_shuffled</span><span class="p">)))</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2_shuffled</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A1</span> <span class="o">-</span> <span class="n">A2_shuffled</span><span class="p">)]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A^{(1)}$&quot;</span><span class="p">,</span> <span class="s2">&quot;$A^{(2),s}$, Network $A^{(2)}$ shuffled&quot;</span><span class="p">,</span> <span class="s2">&quot;$|A^{(1)} - A^{(2),s}|$&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of adjacency disagreements: 25001
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_42_1.png" src="../../_images/graph-matching-vertex_42_1.png" />
</div>
</div>
<div class="section" id="unshuffling-network-2-without-seeds">
<h3><span class="section-number">9.3.5.1. </span>Unshuffling network 2 without seeds<a class="headerlink" href="#unshuffling-network-2-without-seeds" title="Permalink to this headline">¶</a></h3>
<p>First, we will run SGM on network <span class="math notranslate nohighlight">\(A^{(1)}\)</span> and the shuffled network <span class="math notranslate nohighlight">\(A^{(2),s}\)</span> with no seeds, and return the match ratio; that is, the fraction of vertices that have been correctly matched:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># initialize sgm</span>
<span class="n">sgm</span> <span class="o">=</span> <span class="n">GraphMatch</span><span class="p">()</span>
<span class="c1"># fit with A1 and shuffled A2</span>
<span class="n">sgm</span> <span class="o">=</span> <span class="n">sgm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2_shuffled</span><span class="p">)</span>
<span class="c1"># obtain unshuffled version of the shuffled A2</span>
<span class="n">A2_unshuffled_noseed</span> <span class="o">=</span> <span class="n">A2_shuffled</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">sgm</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">,</span> <span class="n">sgm</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">)]</span>
<span class="c1"># compute the match ratio</span>
<span class="n">match_ratio_noseed</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">sgm</span><span class="o">.</span><span class="n">perm_inds_</span><span class="o">-</span><span class="n">node_unshuffle_input</span><span class="p">))</span><span class="o">/</span><span class="n">n_verts</span><span class="p">)</span>
<span class="n">disagreements_noseed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A1</span> <span class="o">-</span> <span class="n">A2_unshuffled_noseed</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Match Ratio, no seeds: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match_ratio_noseed</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Disagreements, no seeds: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements_noseed</span><span class="p">)))</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2_unshuffled_noseed</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A1</span> <span class="o">-</span> <span class="n">A2_unshuffled_noseed</span><span class="p">)]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A^{(1)}$&quot;</span><span class="p">,</span> <span class="s2">&quot;$PA^{(2),s}P^</span><span class="se">\\</span><span class="s2">top$, Network $A^{(2),s}$ unshuffled&quot;</span><span class="p">,</span> <span class="s2">&quot;$|A^{(1)} - PA^{(2),s}P^</span><span class="se">\\</span><span class="s2">top|$&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Match Ratio, no seeds: 0.040
Disagreements, no seeds: 17749
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_45_1.png" src="../../_images/graph-matching-vertex_45_1.png" />
</div>
</div>
<p>While the predicted permutation for <span class="math notranslate nohighlight">\(A^{(2),s}\)</span> after unshuffling was successful in recovering the basic structure of the stochastic block model (i.e. network <span class="math notranslate nohighlight">\(A^{(1)}\)</span> and network <span class="math notranslate nohighlight">\(PA^{(2),s}P^\top\)</span> look qualitatively similar), we see that the number of edge disagreements between them is still quite high, and the match ratio of successfully unshuffled nodes is quite low.</p>
</div>
<div class="section" id="unshuffling-network-2-with-10-seeds">
<h3><span class="section-number">9.3.5.2. </span>Unshuffling network 2 with 10 seeds<a class="headerlink" href="#unshuffling-network-2-with-10-seeds" title="Permalink to this headline">¶</a></h3>
<p>Next, we will run SGM with 10 seeds randomly selected from the optimal permutation vector found ealier. Although 10 seeds is only about 4% of the 300 node network, we will observe below how much more accurate the matching will be compared to having no seeds:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nseeds</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># the number of seeds to use</span>
<span class="c1"># select ten nodes at random from A1 which will serve as seeds</span>
<span class="n">ref_seeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)[:</span><span class="n">nseeds</span><span class="p">])</span>
<span class="c1"># identify the corresponding positions of these `nseeds` nodes</span>
<span class="c1"># in the shuffled version of A2</span>
<span class="n">shuffled_seed_positions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">node_unshuffle_input</span><span class="p">[</span><span class="n">ref_seeds</span><span class="p">])</span>

<span class="c1"># generate sgm instance</span>
<span class="n">sgm</span> <span class="o">=</span> <span class="n">GraphMatch</span><span class="p">()</span>
<span class="c1"># run SGM with A2 and A2s, but provide the seed nodes from A1 as ref_seeds</span>
<span class="c1"># and the corresponding position of these seed nodes after shuffling as shuffled_seed_positions</span>
<span class="n">sgm</span> <span class="o">=</span> <span class="n">sgm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2_shuffled</span><span class="p">,</span> <span class="n">ref_seeds</span><span class="p">,</span> <span class="n">shuffled_seed_positions</span><span class="p">)</span>
<span class="c1"># unshuffle A2s using the optimal permutation of the nodes from sgm</span>
<span class="n">A2_unshuffle_seeds</span> <span class="o">=</span> <span class="n">A2_shuffled</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">sgm</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">,</span> <span class="n">sgm</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">)]</span>

<span class="n">match_ratio_seeds</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">sgm</span><span class="o">.</span><span class="n">perm_inds_</span><span class="o">-</span><span class="n">node_unshuffle_input</span><span class="p">))</span><span class="o">/</span><span class="n">n_verts</span><span class="p">)</span>
<span class="n">disagreements_seeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A1</span> <span class="o">-</span> <span class="n">A2_unshuffle_seeds</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Match Ratio with seeds: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match_ratio_seeds</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Disagreements with seeds: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements_seeds</span><span class="p">)))</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2_unshuffle_seeds</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A1</span> <span class="o">-</span> <span class="n">A2_unshuffle_seeds</span><span class="p">)]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A^{(1)}$&quot;</span><span class="p">,</span> <span class="s2">&quot;$PA^{(2),s}P^</span><span class="se">\\</span><span class="s2">top$, Network $A^{(2),s}$ unshuffled&quot;</span><span class="p">,</span> <span class="s2">&quot;$|A^{(1)} - PA^{(2),s}P^</span><span class="se">\\</span><span class="s2">top|$&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Match Ratio with seeds: 1.000
Disagreements with seeds: 2258
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_49_1.png" src="../../_images/graph-matching-vertex_49_1.png" />
</div>
</div>
<p>From the results above, we see that when running SGM on the same two networks, with no seeds there is match ratio is quite low. However including 10 seeds increases the match ratio to 100% (meaning that the shuffled <span class="math notranslate nohighlight">\(A^{(2),s}\)</span> was completely correctly unshuffled).</p>
</div>
</div>
<div class="section" id="what-happens-when-the-number-of-nodes-aren-t-the-same">
<h2><span class="section-number">9.3.6. </span>What happens when the number of nodes aren’t the same?<a class="headerlink" href="#what-happens-when-the-number-of-nodes-aren-t-the-same" title="Permalink to this headline">¶</a></h2>
<p>From what we’ve seen so far, the two networks you are interested in matching nodes for must have the same number of nodes. In practice, this is a pretty restrictive limitation! You will often come across pairs of networks where many, if not all, of the nodes in the smaller network are matched to a node in the larger network. In this case, you have a dilemma: how do you match the nodes between the networks, but you don’t know what to do with the extra nodes in the larger network. We will do this through a technique called <strong>padded graph matching</strong>, in which we add <em>isolated nodes</em> to the smaller network until it has the same number of nodes as the bigger network, and then we run graph matching on the resulting networks with an equal number of nodes. We have two techniques to add these isolated nodes, naive and adaptive padding.</p>
<p>For these examples, we’ll adjust our example slightly. We’ll keep our first network <span class="math notranslate nohighlight">\(A^{(1)}\)</span> exactly like the network we sampled above from the <span class="math notranslate nohighlight">\(\rho\)</span>-SBM. For <span class="math notranslate nohighlight">\(A^{(2)}\)</span>, we’ll arbitrarily take out the last 25 nodes of each block:</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nremove</span> <span class="o">=</span> <span class="mi">25</span>

<span class="c1"># nodes to retain from A2</span>
<span class="c1"># note: nodes_to_retain is a the mapping from</span>
<span class="c1"># the nodes in A2 to the nodes in A1</span>
<span class="n">n_verts_A2</span> <span class="o">=</span> <span class="n">n_verts</span> <span class="o">-</span> <span class="n">nremove</span><span class="o">*</span><span class="n">n_blocks</span>
<span class="n">nodes_to_retain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="mi">50</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">150</span><span class="p">]]</span>
<span class="p">)</span>
<span class="n">A2_rem</span> <span class="o">=</span> <span class="n">A2</span><span class="p">[</span><span class="n">nodes_to_retain</span><span class="p">,:][:,</span><span class="n">nodes_to_retain</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2</span><span class="p">,</span> <span class="n">A2_rem</span><span class="p">]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A^{(1)}$&quot;</span><span class="p">,</span> <span class="s2">&quot;Network $A^{(2)}$, no nodes removed&quot;</span><span class="p">,</span> <span class="s2">&quot;Network $A^{(2)}$, 25 nodes removed per-block&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph-matching-vertex_52_0.png" src="../../_images/graph-matching-vertex_52_0.png" />
</div>
</div>
<p>which leaves us with a network <span class="math notranslate nohighlight">\(A^{(2)}\)</span> and corresponding underlying random network <span class="math notranslate nohighlight">\(\mathbf A^{(2)}\)</span> in which there are only <span class="math notranslate nohighlight">\(150\)</span> instead of <span class="math notranslate nohighlight">\(225\)</span> nodes. These <span class="math notranslate nohighlight">\(150\)</span> nodes are matched to <span class="math notranslate nohighlight">\(150\)</span> of the <span class="math notranslate nohighlight">\(225\)</span> nodes in <span class="math notranslate nohighlight">\(A_1\)</span> and <span class="math notranslate nohighlight">\(\mathbf A^{(1)}\)</span>, respectively. We won’t shuffle <span class="math notranslate nohighlight">\(A^{(2)}\)</span> this time, but you can trust us these techniques work if your network is shuffled, too!</p>
<p>Your task is to match the <span class="math notranslate nohighlight">\(150\)</span> nodes in <span class="math notranslate nohighlight">\(A^{(2),s}\)</span> to their corresponding matched pair in <span class="math notranslate nohighlight">\(A^{(1)}\)</span>.</p>
<p>Behind the scenes, what you want to do is basically take the network <span class="math notranslate nohighlight">\(A^{(1)}\)</span>, and match <span class="math notranslate nohighlight">\(A^{(2),s}\)</span> to a <em>subnetwork</em> of <span class="math notranslate nohighlight">\(A^{(1)}\)</span> which is <em>induced</em> by the nodes for which there is a corresponding matched pair. By this, what we mean is that we want to figure out which nodes in the larger network <span class="math notranslate nohighlight">\(A^{(1)}\)</span> <em>actually have</em> a matched pair in <span class="math notranslate nohighlight">\(A^{(2)}\)</span>, and virtually <em>ignore</em> the other nodes entirely! In this case, the induced subnetwork of <span class="math notranslate nohighlight">\(A^{(1)}\)</span> looks like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A1_induced</span> <span class="o">=</span> <span class="n">A1</span><span class="p">[</span><span class="n">nodes_to_retain</span><span class="p">,:][:,</span><span class="n">nodes_to_retain</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A1</span><span class="p">,</span> <span class="n">A1_induced</span><span class="p">]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A^{(1)}$&quot;</span><span class="p">,</span> <span class="s2">&quot;Induced Subnetwork of $A^{(1)}$&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph-matching-vertex_56_0.png" src="../../_images/graph-matching-vertex_56_0.png" />
</div>
</div>
<div class="section" id="naive-padded-graph-matching">
<h3><span class="section-number">9.3.6.1. </span>Naive Padded Graph Matching<a class="headerlink" href="#naive-padded-graph-matching" title="Permalink to this headline">¶</a></h3>
<p>Through naive padding, you simply add <em>isolated</em> nodes (if you remember from <a class="reference external" href="#link?">Chapter 4</a>, <em>isolated</em> nodes in a simple network are just nodes which do not have any edges in the network) to the smaller network (which is <span class="math notranslate nohighlight">\(A^{(2)}\)</span>, in your case), until the number of nodes in <span class="math notranslate nohighlight">\(A^{(2)}\)</span> are equal to the number of nodes in <span class="math notranslate nohighlight">\(A^{(1)}\)</span>. The padded version of <span class="math notranslate nohighlight">\(A^{(2),s}\)</span> looks like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A2_padded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">A2_rem</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="n">nremove</span><span class="o">*</span><span class="n">n_blocks</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nremove</span><span class="o">*</span><span class="n">n_blocks</span><span class="p">)])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A2_rem</span><span class="p">,</span> <span class="n">A2_padded</span><span class="p">]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A^{(2)}$, 25 nodes removed per-block&quot;</span><span class="p">,</span> <span class="s2">&quot;Network $A^{(2)}$ after padding&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph-matching-vertex_59_0.png" src="../../_images/graph-matching-vertex_59_0.png" />
</div>
</div>
<p>Which makes the number of nodes in <span class="math notranslate nohighlight">\(A^{(1)}\)</span> and <span class="math notranslate nohighlight">\(A^{(2)}\)</span> the same:</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of nodes in A2, padded: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">A2_padded</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of nodes in A2, padded: 225
</pre></div>
</div>
</div>
</div>
<p>You specify this by instantiating a <code class="docutils literal notranslate"><span class="pre">GraphMatch</span></code> object, using the argument, <code class="docutils literal notranslate"><span class="pre">padding=&quot;naive&quot;</span></code>. Then, you re-run graph matching, optionally, using seeding, just like you did before:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>

<span class="n">nseeds_padded</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">gmp_naive</span> <span class="o">=</span> <span class="n">GraphMatch</span><span class="p">(</span><span class="n">padding</span><span class="o">=</span><span class="s2">&quot;naive&quot;</span><span class="p">)</span>
<span class="c1"># obtain which nodes of A2 will be the seeds to use</span>
<span class="n">rem_seeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">n_verts_A2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">nseeds_padded</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># obtain seeds in A1 which are the indices of the retained nodes</span>
<span class="c1"># of the corresponding seeds in A2</span>
<span class="n">ref_seeds</span> <span class="o">=</span> <span class="n">nodes_to_retain</span><span class="p">[</span><span class="n">rem_seeds</span><span class="p">]</span>

<span class="c1"># run SGM with A1 and A2 with nodes removed</span>
<span class="c1"># since we didn&#39;t shuffle A2, the seeds are the same for both</span>
<span class="n">gmp_naive</span> <span class="o">=</span> <span class="n">gmp_naive</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2_rem</span><span class="p">,</span> <span class="n">ref_seeds</span><span class="p">,</span> <span class="n">rem_seeds</span><span class="p">)</span>

<span class="c1"># unshuffle A2 using the padded version of A2 and the permutation identified</span>
<span class="n">A2_unshuffle_seeds</span> <span class="o">=</span> <span class="n">A2_padded</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">gmp_naive</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">,</span> <span class="n">gmp_naive</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">)]</span>

<span class="n">naive_matching</span> <span class="o">=</span> <span class="n">gmp_naive</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">[</span><span class="n">nodes_to_retain</span><span class="p">]</span>
<span class="n">match_ratio_naive</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">naive_matching</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_verts_A2</span><span class="p">))</span>
<span class="n">disagreements_naive</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A1</span> <span class="o">-</span> <span class="n">A2_unshuffle_seeds</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Match Ratio, naive padding: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match_ratio_naive</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Disagreements, naive padding: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements_naive</span><span class="p">)))</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2_padded</span><span class="p">,</span> <span class="n">A2_unshuffle_seeds</span><span class="p">]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A^{(1)}$&quot;</span><span class="p">,</span> <span class="s2">&quot;Network $A^{(2)}$ after padding&quot;</span><span class="p">,</span> <span class="s2">&quot;Network $A^{(2)}$, naive matched&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Match Ratio, naive padding: 0.053
Disagreements, naive padding: 18750
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_64_1.png" src="../../_images/graph-matching-vertex_64_1.png" />
</div>
</div>
<p>We have managed to match some of the nodes, but the match ratio is still very low, and the number of disagreements is very high. The naive matching of <span class="math notranslate nohighlight">\(A^{(2)}\)</span> after padding looks nothing like <span class="math notranslate nohighlight">\(A^{(1)}\)</span> we were trying to match it to. What happened?</p>
</div>
<div class="section" id="adopted-padded-graph-matching">
<h3><span class="section-number">9.3.6.2. </span>Adopted Padded Graph Matching<a class="headerlink" href="#adopted-padded-graph-matching" title="Permalink to this headline">¶</a></h3>
<p>As it turns out, when we use this naive approach for padded graph matching, we matched <span class="math notranslate nohighlight">\(A^{(2)}\)</span> with the best <em>subnetwork</em> of <span class="math notranslate nohighlight">\(A^{(1)}\)</span>. In practice, what this means is that we took the isolated nodes of <span class="math notranslate nohighlight">\(A^{(2)}\)</span> that we added (just to make the number of nodes align) and attempted to find signal in these nodes. These nodes then, in effect, ended up being aligned to low-density subnetworks of <span class="math notranslate nohighlight">\(A^{(1)}\)</span>, which means that we allowed nodes that didn’t really exist in <span class="math notranslate nohighlight">\(A^{(2)}\)</span> to still have an impact on the matching quality!</p>
<p>Instead, what we want to do is match <span class="math notranslate nohighlight">\(A^{(2)}\)</span> to the best fitting <em>induced subnetwork</em> of <span class="math notranslate nohighlight">\(A^{(1)}\)</span>. The key difference is that, the ideal case, the subnetwork <em>induced</em> on <span class="math notranslate nohighlight">\(A^{(1)}\)</span> is the subnetwork induced by the set of nodes which were <em>actually</em> retained by <span class="math notranslate nohighlight">\(A^{(2)}\)</span>, and <em>not</em> just any old subnetwork.</p>
<p>To do this, we use a strategy called <em>adopted padding</em>, which is performed using <code class="docutils literal notranslate"><span class="pre">padding=&quot;adopted&quot;</span></code> for the <code class="docutils literal notranslate"><span class="pre">GraphMatch</span></code> object. Through adoptive padding, we instead perform graph matching between <span class="math notranslate nohighlight">\(\tilde A^{(1)}\)</span> and a padded version of <span class="math notranslate nohighlight">\(\tilde A^{(2)}\)</span>, where <span class="math notranslate nohighlight">\(\tilde A^{(1)} = 2A^{(1)}\)</span> minus a matrix of ones, and vice-versa for <span class="math notranslate nohighlight">\(\tilde A^{(2)}\)</span>. We again pad <span class="math notranslate nohighlight">\(\tilde A^{(2)}\)</span> exactly like we did before. What this has the effect of is making it so we will <em>discount</em> the padded nodes entirely when performing our graph matching, and will allow us to find the best induced subnetwork instead. We perform this as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gmp_adopted</span> <span class="o">=</span> <span class="n">GraphMatch</span><span class="p">(</span><span class="n">padding</span><span class="o">=</span><span class="s2">&quot;adopted&quot;</span><span class="p">)</span>
<span class="c1"># obtain which nodes of A2 will be the seeds to use</span>
<span class="n">rem_seeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">n_verts_A2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">nseeds_padded</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># obtain seeds in A1 which are the indices of the retained nodes</span>
<span class="c1"># of the corresponding seeds in A2</span>
<span class="n">ref_seeds</span> <span class="o">=</span> <span class="n">nodes_to_retain</span><span class="p">[</span><span class="n">rem_seeds</span><span class="p">]</span>

<span class="c1"># run SGM with A1 and A2 with nodes removed</span>
<span class="c1"># since we didn&#39;t shuffle A2, the seeds are the same for both</span>
<span class="n">gmp_adopted</span> <span class="o">=</span> <span class="n">gmp_adopted</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2_rem</span><span class="p">,</span> <span class="n">ref_seeds</span><span class="p">,</span> <span class="n">rem_seeds</span><span class="p">)</span>

<span class="c1"># unshuffle A2 using the padded version of A2 and the permutation identified</span>
<span class="n">A2_unshuffle_seeds</span> <span class="o">=</span> <span class="n">A2_padded</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">gmp_adopted</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">,</span> <span class="n">gmp_adopted</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">)]</span>

<span class="n">adopted_matching</span> <span class="o">=</span> <span class="n">gmp_adopted</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">[</span><span class="n">nodes_to_retain</span><span class="p">]</span>
<span class="n">match_ratio_adopted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">adopted_matching</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_verts_A2</span><span class="p">))</span>
<span class="n">disagreements_adopted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A1</span> <span class="o">-</span> <span class="n">A2_unshuffle_seeds</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Match Ratio, adopted padding: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match_ratio_adopted</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Disagreements, adopted padding: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements_adopted</span><span class="p">)))</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A1</span><span class="p">,</span> <span class="n">A2_padded</span><span class="p">,</span> <span class="n">A2_unshuffle_seeds</span><span class="p">]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A^{(1)}$&quot;</span><span class="p">,</span> <span class="s2">&quot;Network $A^{(2)}$ after padding&quot;</span><span class="p">,</span> <span class="s2">&quot;Network $A^{(2)}$, adopted matched&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Match Ratio, adopted padding: 1.000
Disagreements, adopted padding: 13757
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_68_1.png" src="../../_images/graph-matching-vertex_68_1.png" />
</div>
</div>
<p>Using adopted matching has increased the match ratio to perfect, but the number of disagreements is <em>still</em> pretty high!</p>
<p>As it turns out, since we have isolated nodes in the network, a better way to view this comparison would be to look at <span class="math notranslate nohighlight">\(A^{(1)}\)</span> on the <em>subnetwork induced</em> by the non-isolated nodes of <span class="math notranslate nohighlight">\(A^{(2)}\)</span>, and compute the number of disagreements here instead:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nonisolates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A2_unshuffle_seeds</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">A1_ind_by_nonis</span> <span class="o">=</span> <span class="n">A1</span><span class="p">[</span><span class="n">nonisolates</span><span class="p">,:][:,</span><span class="n">nonisolates</span><span class="p">]</span>
<span class="n">A2_ind_by_nonis_unshuf</span> <span class="o">=</span> <span class="n">A2_unshuffle_seeds</span><span class="p">[</span><span class="n">nonisolates</span><span class="p">,:][:,</span><span class="n">nonisolates</span><span class="p">]</span>
<span class="n">disagreements_naive_nonisolates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A1_ind_by_nonis</span> <span class="o">-</span> <span class="n">A2_ind_by_nonis_unshuf</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Disagreements, adoptive padding, non-isolates: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements_naive_nonisolates</span><span class="p">)))</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A1</span><span class="p">,</span> <span class="n">A1_ind_by_nonis</span><span class="p">,</span> <span class="n">A2_ind_by_nonis_unshuf</span><span class="p">]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A^{(1)}$&quot;</span><span class="p">,</span> <span class="s2">&quot;Network $A^{(1)}$, isolates of $A^{(2)}$ removed&quot;</span><span class="p">,</span> <span class="s2">&quot;Network $A^{(2)}$, adopted match&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Disagreements, adoptive padding, non-isolates: 1068
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_72_1.png" src="../../_images/graph-matching-vertex_72_1.png" />
</div>
</div>
<p>Which is much more reasonable.</p>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./applications/ch9"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="significant-communities.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">9.2. </span>Differences in Block Matrices</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="multiple-vertex-nomination.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">9.4. </span>Vertex Nomination For Two Networks</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Eric Bridgeford, Alex Loftus, and Joshua Vogelstein<br/>
    
        &copy; Copyright 2022.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>