
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>7.3. Graph Matching &#8212; Hands-on Network Machine Learning with Scikit-Learn and Graspologic</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="7.4. Vertex Nomination For Two Networks" href="multiple-vertex-nomination.html" />
    <link rel="prev" title="7.2. Two-sample hypothesis testing in SBMs" href="significant-communities.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Hands-on Network Machine Learning with Scikit-Learn and Graspologic</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../coverpage.html">
                    Hands-on Network Machine Learning with Scikit-Learn and Graspologic
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Introduction
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../introduction/preface.html">
   Preface
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../introduction/terminology.html">
   Terminology
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Foundations
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../foundations/ch1/ch1.html">
   1. The Network Machine Learning Landscape
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch1/what-is-a-network.html">
     1.1. What is network machine learning?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch1/why-study-networks.html">
     1.2. Why do we study networks?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch1/types-nml-problems.html">
     1.3. Types of Network Machine Learning Problems
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch1/challenges-of-nml.html">
     1.4. Challenges of Network Machine Learning
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../foundations/ch2/ch2.html">
   2. End-to-end Biology Network Machine Learning Project
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch2/big-picture.html">
     2.1. Look at the big picture
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch2/get-the-data.html">
     2.2. Get the Data
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch2/prepare-the-data.html">
     2.3. Prepare the Data for Network Algorithms
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch2/select-and-train.html">
     2.4. Select and Train a Model
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch2/fine-tune.html">
     2.5. Fine-Tune your Model
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../foundations/ch2/discover-and-visualize.html">
     2.6. Discover and Visualize the Data to Gain Insights
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Representations
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../representations/ch4/ch4.html">
   3. Properties of Networks as a Statistical Object
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch4/matrix-representations.html">
     3.1. Matrix Representations Of Networks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch4/properties-of-networks.html">
     3.2. Properties of Networks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch4/network-representations.html">
     3.3. Representations of Networks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch4/regularization.html">
     3.4. Regularization
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../representations/ch5/ch5.html">
   4. Why Use Statistical Models?
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch5/single-network-models_ER.html">
     4.1. Erdös-Rényi (ER) Random Networks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch5/single-network-models_SBM.html">
     4.2. Stochastic Block Models (SBM)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch5/single-network-models_RDPG.html">
     4.3. Random Dot Product Graphs (RDPG)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch5/single-network-models_IER.html">
     4.4. Inhomogeneous Erdos Renyi (IER) Random Network Model
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch5/single-network-models_DCSBM.html">
     4.5. Degree-Corrected Stochastic Block Model (DCSBM)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch5/single-network-models_SIEM.html">
     4.6. Structured Independent Edge Model (SIEM)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch5/multi-network-models.html">
     4.7. Multiple Network Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch5/models-with-covariates.html">
     4.8. Network Models with Network Covariates
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../representations/ch6/ch6.html">
   5. Learning Network Representations
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch6/estimating-parameters_mle.html">
     5.1. Estimating Parameters in Network Models via MLE
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch6/why-embed-networks.html">
     5.2. Why embed networks?
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch6/spectral-embedding.html">
     5.3. Spectral embedding methods
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch6/multigraph-representation-learning.html">
     5.4. Multiple-Network Representation Learning
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../representations/ch6/joint-representation-learning.html">
     5.5. Joint Representation Learning
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Applications
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch7/ch7.html">
   6. Applications When You Have One Network
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/>
  <label for="toctree-checkbox-6">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch7/community-detection.html">
     6.1. Community Detection
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch7/testing-differences.html">
     6.2. Testing for Differences between Groups of Edges
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch7/model-selection.html">
     6.3. Model Selection
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch7/vertex-nomination.html">
     6.4. Single-Network Vertex Nomination
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch7/out-of-sample.html">
     6.5. Out-of-sample Embedding
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="ch8.html">
   7. Applications for Two Networks
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/>
  <label for="toctree-checkbox-7">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="two-sample-hypothesis.html">
     7.1. Latent Two-Sample Hypothesis Testing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="significant-communities.html">
     7.2. Two-sample hypothesis testing in SBMs
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     7.3. Graph Matching
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="multiple-vertex-nomination.html">
     7.4. Vertex Nomination For Two Networks
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../ch9/ch9.html">
   8. Applications for Many Networks
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/>
  <label for="toctree-checkbox-8">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch9/anomaly-detection.html">
     8.1. Anomaly Detection For Timeseries of Networks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch9/significant-edges.html">
     8.2. Testing for Significant Edges
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../ch9/significant-vertices.html">
     8.3. Testing for Significant Vertices
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Next Steps
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../next/ch10/ch10.html">
   9. Where do we go from here?
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/>
  <label for="toctree-checkbox-9">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../next/ch10/random-walk-diffusion-methods.html">
     9.1. Random walk and diffusion-based methods
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../next/ch10/gnn.html">
     9.2. Graph Neural Networks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../next/ch10/sparsity.html">
     9.3. Network Sparsity
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Appendix
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../appendix/ch11/ch11.html">
   10. Representations (Extended)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" type="checkbox"/>
  <label for="toctree-checkbox-10">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../appendix/ch11/alt-reps.html">
     10.1. Alternative Network Representations
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../appendix/ch12/ch12.html">
   11. Network Model Theory
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" type="checkbox"/>
  <label for="toctree-checkbox-11">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../appendix/ch12/background.html">
     11.2. Background
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../appendix/ch12/foundation.html">
     11.3. Foundation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../appendix/ch12/ers.html">
     11.4. Erdös-Rényi (ER) Random Networks
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../appendix/ch12/sbms.html">
     11.5. Stochastic Block Models
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../appendix/ch12/rdpgs.html">
     11.6. RDPGs and more general network models
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../appendix/ch13/ch13.html">
   12. Learning Representations Theory
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" type="checkbox"/>
  <label for="toctree-checkbox-12">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../appendix/ch13/mle-theory.html">
     12.1. Maximum Likelihood Estimate Theory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../appendix/ch13/spectral-theory.html">
     12.2. Spectral Method Theory
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../../appendix/ch14/ch14.html">
   13. Applications (Extended)
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" type="checkbox"/>
  <label for="toctree-checkbox-13">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../../appendix/ch14/hypothesis.html">
     13.1. Hypothesis Testing with coin flips
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../appendix/ch14/unsupervised.html">
     13.2. Unsupervised learning
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../../appendix/ch14/bayes.html">
     13.3. Bayes Plugin Classifier
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Reference
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference external" href="https://graspologic.readthedocs.io/en/latest/">
   Graspologic Documentation
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/neurodata/graph-stats-book/master?urlpath=tree/network_machine_learning_in_python/applications/ch8/graph-matching-vertex.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/neurodata/graph-stats-book"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/neurodata/graph-stats-book/issues/new?title=Issue%20on%20page%20%2Fapplications/ch8/graph-matching-vertex.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/neurodata/graph-stats-book/edit/master/network_machine_learning_in_python/applications/ch8/graph-matching-vertex.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Edit this page"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="headerbtn__text-container">suggest edit</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../../_sources/applications/ch8/graph-matching-vertex.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#defining-a-similarity-metric">
   7.3.1. Defining a similarity metric
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#graph-matching-small-networks">
   7.3.2. Graph Matching Small Networks
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#permutation-matrices">
   7.3.3. Permutation Matrices
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id2">
     7.3.3.1. Permutation matrices
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#p-top-b-moves-the-rows">
       7.3.3.1.1.
       <span class="math notranslate nohighlight">
        \(P^\top B\)
       </span>
       moves the rows
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#cp-moves-the-columns">
     7.3.3.2.
     <span class="math notranslate nohighlight">
      \(CP\)
     </span>
     moves the columns
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#p-top-dp-moves-the-rows-and-columns-concurrently">
     7.3.3.3.
     <span class="math notranslate nohighlight">
      \(P^\top DP\)
     </span>
     moves the rows and columns concurrently
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#using-concurrent-row-and-column-permutations-on-adjacency-matrices">
     7.3.3.4. Using concurrent row and column permutations on adjacency matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#permutation-matrices-to-match-network">
     7.3.3.5. Permutation Matrices to Match Network
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#generating-a-random-permutation-matrix">
       7.3.3.5.1. Generating a random permutation matrix
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#finding-a-good-permutation-with-gradient-descent-optimization">
   7.3.4. Finding a good permutation with gradient descent optimization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#graph-matching-with-graspologic">
   7.3.5. Graph matching with graspologic
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-match-ratio-of-nodes">
     7.3.5.1. The match ratio of nodes
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#seeds">
     7.3.5.2. Seeds
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#seeded-graph-matching-sgm-on-correlated-network-pairs">
   7.3.6. Seeded Graph Matching (SGM) on Correlated Network Pairs
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#matching-network-2-without-seeds">
     7.3.6.1. matching network 2 without seeds
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unshuffling-network-2-with-10-seeds">
     7.3.6.2. Unshuffling network 2 with 10 seeds
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#what-happens-when-the-number-of-nodes-aren-t-the-same">
   7.3.7. What happens when the number of nodes aren’t the same?
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#naive-padded-graph-matching">
     7.3.7.1. Naive Padded Graph Matching
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#adopted-padded-graph-matching">
     7.3.7.2. Adopted Padded Graph Matching
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#references">
   7.3.8. References
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Graph Matching</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#defining-a-similarity-metric">
   7.3.1. Defining a similarity metric
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#graph-matching-small-networks">
   7.3.2. Graph Matching Small Networks
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#permutation-matrices">
   7.3.3. Permutation Matrices
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#id2">
     7.3.3.1. Permutation matrices
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#p-top-b-moves-the-rows">
       7.3.3.1.1.
       <span class="math notranslate nohighlight">
        \(P^\top B\)
       </span>
       moves the rows
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#cp-moves-the-columns">
     7.3.3.2.
     <span class="math notranslate nohighlight">
      \(CP\)
     </span>
     moves the columns
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#p-top-dp-moves-the-rows-and-columns-concurrently">
     7.3.3.3.
     <span class="math notranslate nohighlight">
      \(P^\top DP\)
     </span>
     moves the rows and columns concurrently
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#using-concurrent-row-and-column-permutations-on-adjacency-matrices">
     7.3.3.4. Using concurrent row and column permutations on adjacency matrices
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#permutation-matrices-to-match-network">
     7.3.3.5. Permutation Matrices to Match Network
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#generating-a-random-permutation-matrix">
       7.3.3.5.1. Generating a random permutation matrix
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#finding-a-good-permutation-with-gradient-descent-optimization">
   7.3.4. Finding a good permutation with gradient descent optimization
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#graph-matching-with-graspologic">
   7.3.5. Graph matching with graspologic
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#the-match-ratio-of-nodes">
     7.3.5.1. The match ratio of nodes
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#seeds">
     7.3.5.2. Seeds
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#seeded-graph-matching-sgm-on-correlated-network-pairs">
   7.3.6. Seeded Graph Matching (SGM) on Correlated Network Pairs
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#matching-network-2-without-seeds">
     7.3.6.1. matching network 2 without seeds
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unshuffling-network-2-with-10-seeds">
     7.3.6.2. Unshuffling network 2 with 10 seeds
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#what-happens-when-the-number-of-nodes-aren-t-the-same">
   7.3.7. What happens when the number of nodes aren’t the same?
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#naive-padded-graph-matching">
     7.3.7.1. Naive Padded Graph Matching
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#adopted-padded-graph-matching">
     7.3.7.2. Adopted Padded Graph Matching
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#references">
   7.3.8. References
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="graph-matching">
<span id="ch8-gm"></span><h1><span class="section-number">7.3. </span>Graph Matching<a class="headerlink" href="#graph-matching" title="Permalink to this headline">#</a></h1>
<p>You work at Facebook and Twitter, but there’s been a terrible incident on the Twitter end. All Twitter users’ names and handles have been somehow been deleted! Your bosses are furious and have tasked you with somehow recovering the lost information. How might you go about doing this? Luckily, you’ve been working hard and have somehow earned yourself this dual Facebook/Twitter gig, so you have a great resource at your disposal: the Facebook social network. You know all facebook users and who they are friends with, and since you’ve only lost the twitter usernames, you can still figure out which unnamed twitter users follow each other. You decide to use the Facebook network connectivity data to re-label the twitter social network. Alternatively, you can say the we are “aligning” Twitter based on Facebook.</p>
<p>In the two social networks above, each user is a node and an edge exists if two users are friends. We’ll define the facebook and twitter networks as <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(T\)</span> respectively, with associated adjacency matrices <span class="math notranslate nohighlight">\(A_F\)</span> and <span class="math notranslate nohighlight">\(A_T\)</span>. Aligning the nodes of two networks is known as <em>Graph Matching</em>, because we are matching the node indices of one network (or, <em>graph</em>) to another. This can also be thought of as a mapping; that is, based on the neighbors of a node in <span class="math notranslate nohighlight">\(F\)</span>, you find a node in <span class="math notranslate nohighlight">\(T\)</span> with the most similar neighborhood structure, then give the two nodes the same index. In other words, one of our Twitter users will be assigned the user name of the Facebook user with the most connections in common. This is done for the whole network, with the end result being that overall the structure is best preserved.</p>
<p>There are a ton of ways to match the nodes of two networks. In fact, for network pairs with <span class="math notranslate nohighlight">\(n\)</span> nodes, there are <span class="math notranslate nohighlight">\(n!\)</span> possible mappings; for example, when <span class="math notranslate nohighlight">\(n=100\)</span>, there are more than <span class="math notranslate nohighlight">\(10^{157}\)</span> possible matchings. So how would we go about figuring out which mapping is best without the computationally gargantuan task of checking each one? This problem is known as the graph matching problem, and it is discussed in <span id="id1">[<a class="reference internal" href="#id89" title="Lorenzo Livi and Antonello Rizzi. The graph matching problem. Pattern Anal. Appl., 16(3):253–283, August 2013. doi:10.1007/s10044-012-0284-8.">1</a>]</span>.</p>
<section id="defining-a-similarity-metric">
<h2><span class="section-number">7.3.1. </span>Defining a similarity metric<a class="headerlink" href="#defining-a-similarity-metric" title="Permalink to this headline">#</a></h2>
<p>First, we need a metric that tells us how similar two networks are to each other. For graph matching, this similarity metric is defined as <span class="math notranslate nohighlight">\(f(A, B) = ||A - B||_F^2\)</span> for unweighted adjacency matrices <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>, the Frobenius distance from <a class="reference internal" href="../../representations/ch6/spectral-embedding.html#ch6:se:frob_dist">Definition 5.2</a>.</p>
<p>This quantity is the same Frobenius norm we saw back a few sections ago, when we learned about two-sample testing in <a class="reference internal" href="two-sample-hypothesis.html#ch8-twosample"><span class="std std-numref">Section 7.1</span></a>. To understand this functionally, consider the best possible case where where the two networks (here they are two triangles) are identical: <span class="math notranslate nohighlight">\(A=B\)</span>.</p>
<div class="math">
\[
A = 
\begin{array}{cc} &
\begin{array}{ccc} 0 & 1 & 2 \end{array}
\\
\begin{array}{ccc}
0 \\
1 \\
2 \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 1\\
1 & 0 & 1\\
1 & 1 & 0\end{array}
\right)\end{array}
\quad \quad
B = 
\begin{array}{cc} &
\begin{array}{ccc} 0 & 1 & 2 \end{array}
\\
\begin{array}{ccc}
0 \\
1 \\
2 \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 1\\
1 & 0 & 1\\
1 & 1 & 0\end{array}
\right)\end{array}
\\
A-B =
\begin{array}{cc} &
\begin{array}{ccc} 0 & 1 & 2 \end{array}
\\
\begin{array}{ccc}
0 \\
1 \\
2 \end{array}
&
\left(
\begin{array}{ccc}
0 & 0 & 0\\
0 & 0 & 0\\
0 & 0 & 0\end{array}
\right)\end{array}
\\
||A - B||_F^2 = 0
\]
    </div>
As we see above, the difference will be a matrix of all zeros, and taking the squared Frobenius norm will then yield $f(A,B) = 0$. This is because all of the element-wise differences $a_{ij} - b_{ij}$ are just zero, and hence both their square (and sum) will also be zero. Below we remove one edge from $B$,
<div class="math">
\[
A = 
\begin{array}{cc} &
\begin{array}{ccc} 0 & 1 & 2 \end{array}
\\
\begin{array}{ccc}
0 \\
1 \\
2 \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 1\\
1 & 0 & 1\\
1 & 1 & 0\end{array}
\right)\end{array}
\quad \quad
B = 
\begin{array}{cc} &
\begin{array}{ccc} 0 & 1 & 2 \end{array}
\\
\begin{array}{ccc}
0 \\
1 \\
2 \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 1\\
1 & 0 & 0\\
1 & 0 & 0\end{array}
\right)\end{array}
\\
A-B =
\begin{array}{cc} &
\begin{array}{ccc} 0 & 1 & 2 \end{array}
\\
\begin{array}{ccc}
0 \\
1 \\
2 \end{array}
&
\left(
\begin{array}{ccc}
0 & 0 & 0\\
0 & 0 & 1\\
0 & 1 & 0\end{array}
\right)\end{array}
\\
||A - B||_F^2 = 2
\]
    </div>
<p>then <span class="math notranslate nohighlight">\(f(A,B) = 2\)</span>.
In this sense for undirected networks, the metric effectively counts the total number of disagreements in the adjacency matrices between <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>. Thus, we want to find the mapping where <span class="math notranslate nohighlight">\(f(A, B)\)</span> is as small as possible.</p>
</section>
<section id="graph-matching-small-networks">
<h2><span class="section-number">7.3.2. </span>Graph Matching Small Networks<a class="headerlink" href="#graph-matching-small-networks" title="Permalink to this headline">#</a></h2>
<p>Say we have the network pairs below, <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(F\)</span>. They have four nodes each, <span class="math notranslate nohighlight">\(\{1, 2, 3, 4\}\)</span> for <span class="math notranslate nohighlight">\(T\)</span>, and <span class="math notranslate nohighlight">\(\{a, b, c, d\}\)</span> for <span class="math notranslate nohighlight">\(F\)</span>. In this case, the nodes represent people within the social networks, and the edges represent whether two people are connected on the social networking site. In this case, we will assume we have a node correspondance:</p>
<ol class="simple">
<li><p>Person <span class="math notranslate nohighlight">\(0\)</span> on Twitter is person <span class="math notranslate nohighlight">\(a\)</span> on Facebook,</p></li>
<li><p>Person <span class="math notranslate nohighlight">\(1\)</span> on Twitter is person <span class="math notranslate nohighlight">\(b\)</span> on Facebook,</p></li>
<li><p>Person <span class="math notranslate nohighlight">\(2\)</span> on Twitter is person <span class="math notranslate nohighlight">\(c\)</span> on Facebook,</p></li>
<li><p>Person <span class="math notranslate nohighlight">\(3\)</span> on Twitter is person <span class="math notranslate nohighlight">\(d\)</span> on Facebook.</p></li>
</ol>
<p>The corresponding adjacency matrices of the two networks are equal to each other when the nodes are laid out for <span class="math notranslate nohighlight">\(A_T\)</span> as <span class="math notranslate nohighlight">\(\{0, 1, 2, 3\}\)</span>, and when the nodes are laid out for <span class="math notranslate nohighlight">\(A_F\)</span> as <span class="math notranslate nohighlight">\(\{a,b,c,d\}\)</span>.</p>
<p><img alt="gm_11" src="../../_images/gm_1.png" /></p>
<div class="math">
\[
A_T = 
\begin{array}{cc} &
\begin{array}{cccc} 0 & 1 & 2 & 3 \end{array}
\\
\begin{array}{cccc}
0 \\
1 \\
2 \\
3 \end{array}
&
\left(
\begin{array}{cccc}
0 & 1 & 1 & 0\\
1 & 0 & 0 & 1\\
1 & 0 & 0 & 1\\
0 & 1 & 1 & 0\end{array}
\right)\end{array}
\quad \quad
A_F = 
\begin{array}{cc} &
\begin{array}{cccc} a & b & c & d \end{array}
\\
\begin{array}{ccc}
a \\
b \\
c \\
d \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 1 & 0\\
1 & 0 & 0 & 1\\
1 & 0 & 0 & 1\\
0 & 1 & 1 & 0\end{array}
\right)\end{array} \\
|A_T - A_F| = \left(
\begin{array}{ccc}
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\end{array}
\right)
\]
    </div>
<p>And as we learned above, therefore <span class="math notranslate nohighlight">\(f(A_T, A_B) = 0\)</span>. As we can see, when we compare the networks with the nodes ordered correctly (Person <span class="math notranslate nohighlight">\(1\)</span> Twitter is the first node, Person <span class="math notranslate nohighlight">\(a\)</span> from Facebook is its first node, Person <span class="math notranslate nohighlight">\(2\)</span> from Twitter is the first node of <span class="math notranslate nohighlight">\(A_T\)</span>, Person <span class="math notranslate nohighlight">\(b\)</span> from Facebook is the second node of <span class="math notranslate nohighlight">\(A_F\)</span>, so on and so forth). What we’ve done here by ordering the nodes in such tuples is implicitly made the statement that, there is something similar about the nodes <span class="math notranslate nohighlight">\(j\)</span> between Twitter and Facebook, and therefore, ordering the adjacency matrices while obeying this similarity is going to give us a <em>low</em> edge disagreement (here, just zero).</p>
<p>We can see this easily, by considering what happens if we rearrange the nodes <em>simultaneously</em> for each network. Let’s instead order the nodes for Twitter and Facebook as <span class="math notranslate nohighlight">\(\{2, 0, 1, 3\}\)</span> and <span class="math notranslate nohighlight">\(\{c, a, b, d\}\)</span>, respectively. We will call these new adjacency matrices with the new node ordering <span class="math notranslate nohighlight">\(A_T''\)</span> and <span class="math notranslate nohighlight">\(A_F''\)</span> respectively:</p>
<div class="math">
\[
A_T = 
\begin{array}{cc} &
\begin{array}{cccc} 2 & 0 & 1 & 3 \end{array}
\\
\begin{array}{cccc}
2 \\
0 \\
1 \\
3 \end{array}
&
\left(
\begin{array}{cccc}
0 & 1 & 0 & 1 \\
1 & 0 & 1 & 0\\
0 & 1 & 0 & 1\\
1 & 0 & 1 & 0
\end{array}
\right)\end{array}
\quad \quad
A_F = 
\begin{array}{cc} &
\begin{array}{cccc} c & a & b & d \end{array}
\\
\begin{array}{ccc}
c \\
a \\
b \\
d \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 0 & 1 \\
1 & 0 & 1 & 0\\
0 & 1 & 0 & 1\\
1 & 0 & 1 & 0
\end{array}
\right)\end{array} \\
|A_T - A_F| = \left(
\begin{array}{ccc}
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\end{array}
\right)
\]
    </div>
<p>The idea is that, even though the ordering of the nodes is different, we have maintained that <em>like goes with like</em>: the first node for Twitter is node <span class="math notranslate nohighlight">\(2\)</span> and the first node for Facebook is node <span class="math notranslate nohighlight">\(c\)</span>, the second node for Twitter is <span class="math notranslate nohighlight">\(0\)</span> and the second node for Facebook is node <span class="math notranslate nohighlight">\(a\)</span>, so on and so forth. The node orderings preserve the <em>correspondance</em> between the nodes of Twitter with the nodes of Facebook.</p>
<p>Unfortunately, nothing in life nor network machine learning is ever this simple. The spatial layout of a network’s nodes is arbirary, and in reality it can often be much harder to tell whether two networks are the same. For graph matching, we don’t actually <em>know</em> the node correspondance between the two networks: we have no idea that person <span class="math notranslate nohighlight">\(0\)</span> on Twitter is person <span class="math notranslate nohighlight">\(a\)</span> on Facebook, person <span class="math notranslate nohighlight">\(1\)</span> on Twitter is person <span class="math notranslate nohighlight">\(b\)</span> on Facebook, so on and so forth.</p>
<p>For instance, we can swap the spatial location of nodes <span class="math notranslate nohighlight">\(c\)</span> and <span class="math notranslate nohighlight">\(d\)</span> in network <span class="math notranslate nohighlight">\(F\)</span>, as shown below. Even with such a small network, it’s hard to tell whether the networks are the same.</p>
<p><img alt="gm_22" src="../../_images/gm_2.png" /></p>
<p>Further, let’s say we just had an arbitrary ordering of the nodes for Facebook, which is now a little bit different from the one which we just saw. Let’s imagine we have the nodes ordered instead as <span class="math notranslate nohighlight">\(\{a, b, d, c\}\)</span> instead of <span class="math notranslate nohighlight">\(\{a, b, c, d\}\)</span>, like we did before, but Twitter’s nodes are still ordered as <span class="math notranslate nohighlight">\(\{0, 1, 2, 3\}\)</span>. Now, the adjacency matrices won’t be equal either, where we use <span class="math notranslate nohighlight">\(A_F'\)</span> to denote the adjacency matrix for the Facebook network with this new node ordering:</p>
<div class="math">
\[
A_T = 
\begin{array}{cc} &
\begin{array}{cccc} 0 & 1 & 2 & 3 \end{array}
\\
\begin{array}{cccc}
0 \\
1 \\
2 \\
3 \end{array}
&
\left(
\begin{array}{cccc}
0 & 1 & 1 & 0\\
1 & 0 & 0 & 1\\
1 & 0 & 0 & 1\\
0 & 1 & 1 & 0\end{array}
\right)\end{array}
\quad \quad
A_F' = 
\begin{array}{cc} &
\begin{array}{cccc} a & b & d & c \end{array}
\\
\begin{array}{ccc}
a \\
b \\
d \\
c \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 0 & 1\\
1 & 0 & 1 & 0\\
0 & 1 & 0 & 1\\
1 & 0 & 1 & 0\end{array}
\right)\end{array} \\
|A_T - A_F'| = \left(
\begin{array}{ccc}
0 & 0 & 1 & 1\\
0 & 0 & 1 & 1\\
1 & 1 & 0 & 0\\
1 & 1 & 0 & 0\end{array}
\right)
\]
    </div>
<p>and we get that <span class="math notranslate nohighlight">\(f(A_T, A_F') = 8\)</span>, since there are <span class="math notranslate nohighlight">\(8\)</span> entries which are different in the adjacency matrices between <span class="math notranslate nohighlight">\(A_T\)</span> and <span class="math notranslate nohighlight">\(A_F\)</span>. This might seem a bit high, but note that because the network is undirected, adjecency disagreements are effectively counted twice (a single edge disagreement for an edge <span class="math notranslate nohighlight">\((i,j)\)</span> also yield a difference for edge <span class="math notranslate nohighlight">\((j, i)\)</span>, since the adjacency matrix is symmetric). By comparing the nodes of Twitter and Facebook with the nodes <em>misaligned</em>, we have effectively <em>broken</em> the node correspondance between the nodes of Twitter and Facebook.</p>
<p>In this sense, we can see how networks with a low number of edge disagreements might be considered to be better <em>matches</em> in terms of the node correspondance. When the nodes are <em>aligned</em> in a way which respects the node correspondance, identical networks have a low number of disagreements, and when the nodes are <em>aligned</em> in a way which disregards the node correspodance, the networks have a high number of disagreements. We will build upon this idea further, by exploring how to manipulate our adjacency matrices such that we can find alignments that match well. You can do this using something called a permutation matrix.</p>
</section>
<section id="permutation-matrices">
<h2><span class="section-number">7.3.3. </span>Permutation Matrices<a class="headerlink" href="#permutation-matrices" title="Permalink to this headline">#</a></h2>
<p>Permutation matrices are used to shuffle around the rows and columns of other matrices. A permutation matrix is a matrix of all ones and zeros, where each row and column adds up to one. In other words, each row has exactly one entry equal to one, with the rest being zeros; the same is true for the columns.</p>
<section id="id2">
<h3><span class="section-number">7.3.3.1. </span>Permutation matrices<a class="headerlink" href="#id2" title="Permalink to this headline">#</a></h3>
<p>Permutation matrices are commonly used as a method to move around the rows and columns of a square matrix. A <strong>permutation matrix</strong> is a matrix where, for every row and column, exactly one entry has a value of one.</p>
<section id="p-top-b-moves-the-rows">
<h4><span class="section-number">7.3.3.1.1. </span><span class="math notranslate nohighlight">\(P^\top B\)</span> moves the rows<a class="headerlink" href="#p-top-b-moves-the-rows" title="Permalink to this headline">#</a></h4>
<p>Let’s consider a matrix <span class="math notranslate nohighlight">\(B\)</span> where all entries of the first row have a value of one, all entries of the second row have a value of two, all entries of the third row have a value of three, and all entries of the fourth row have a value of four. We can apply a permutation matrix <span class="math notranslate nohighlight">\(P\)</span> to swap the rows around with the following heuristic. If the matrix <span class="math notranslate nohighlight">\(P\)</span> has an entry <span class="math notranslate nohighlight">\(p_{ji}\)</span> which is one, then in the resulting matrix, the row <span class="math notranslate nohighlight">\(i\)</span> will be the row <span class="math notranslate nohighlight">\(j\)</span> from the matrix we permuted.</p>
<p>For instance, in the following example, the values <span class="math notranslate nohighlight">\(p_{12}\)</span>, <span class="math notranslate nohighlight">\(p_{23}\)</span>, <span class="math notranslate nohighlight">\(p_{34}\)</span>, and <span class="math notranslate nohighlight">\(p_{41}\)</span> all have values of one, which means we will reorder the rows of <span class="math notranslate nohighlight">\(B\)</span> so that <span class="math notranslate nohighlight">\(P^\top B\)</span> will have the top row being the second row from the original matrix (and will have a value of two), the second row will be the third row from the original matrix (and will have a value of three), the third row will be the fourth row from the original matrix (and will have a value of four), and the fourth row will be the first row from the original matrix (and will have a value of one.</p>
<p>We apply this “row” permutation with the matrix multiplication <span class="math notranslate nohighlight">\(PB\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>

<span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="c1"># Pt * B</span>
<span class="n">PtB</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">B</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">graphbook_code</span> <span class="kn">import</span> <span class="n">heatmap</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">graphbook_code</span> <span class="kn">import</span> <span class="n">cmaps</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">B</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">PtB</span><span class="p">]</span>
<span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Original matrix $B$&quot;</span><span class="p">,</span> <span class="s2">&quot;Permutation Matrix $P$&quot;</span><span class="p">,</span> <span class="s2">&quot;Row Permutation $P^</span><span class="se">\\</span><span class="s2">top B$&quot;</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">],</span> <span class="n">title</span> <span class="o">=</span> <span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Column&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Row&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph-matching-vertex_11_0.png" src="../../_images/graph-matching-vertex_11_0.png" />
</div>
</div>
</section>
</section>
<section id="cp-moves-the-columns">
<h3><span class="section-number">7.3.3.2. </span><span class="math notranslate nohighlight">\(CP\)</span> moves the columns<a class="headerlink" href="#cp-moves-the-columns" title="Permalink to this headline">#</a></h3>
<p>Likewise, a column permutation behaves very similarly. Let’s now consider a matrix <span class="math notranslate nohighlight">\(C\)</span>, where the first column has a value of one, the second column has a value of two, the third column has a value of three, and the fourth column has a value of four. We use the same permutation matrix, where here, <span class="math notranslate nohighlight">\(p_{ji}\)</span> indicates that column <span class="math notranslate nohighlight">\(i\)</span> of the new matrix will be column <span class="math notranslate nohighlight">\(j\)</span> from the matrix before the permutation was applied. We apply the column permutation matrix as <span class="math notranslate nohighlight">\(CP\)</span>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>

<span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="c1"># C * P</span>
<span class="n">CP</span> <span class="o">=</span> <span class="n">C</span> <span class="o">@</span> <span class="n">P</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">C</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">CP</span><span class="p">]</span>
<span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Original matrix $C$&quot;</span><span class="p">,</span> <span class="s2">&quot;Permutation Matrix $P$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;Column Permutation $CP$&quot;</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">],</span> <span class="n">title</span> <span class="o">=</span> <span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Column&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Row&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph-matching-vertex_14_0.png" src="../../_images/graph-matching-vertex_14_0.png" />
</div>
</div>
</section>
<section id="p-top-dp-moves-the-rows-and-columns-concurrently">
<h3><span class="section-number">7.3.3.3. </span><span class="math notranslate nohighlight">\(P^\top DP\)</span> moves the rows and columns concurrently<a class="headerlink" href="#p-top-dp-moves-the-rows-and-columns-concurrently" title="Permalink to this headline">#</a></h3>
<p>As an interesting property of permutation matrices, we can apply these operations sequentially to reorder both the rows <em>and</em> columns of a matrix. Consider, for instance, a permutation matrix where row/column <span class="math notranslate nohighlight">\(1\)</span> of the original matrix becomes row/column <span class="math notranslate nohighlight">\(2\)</span> of the new matrix, and likewise, row/column <span class="math notranslate nohighlight">\(2\)</span> of the original matrix becomes row/column <span class="math notranslate nohighlight">\(1\)</span> of the new matrix. We’ll consider a matrix <span class="math notranslate nohighlight">\(D\)</span> where the first row and first column both have entries of all ones, and the rest of the matrix has the value zero. The original matrix and the permutation matrix look like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>

<span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">D</span><span class="p">,</span> <span class="n">P</span><span class="p">]</span>
<span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Original matrix $D$&quot;</span><span class="p">,</span> <span class="s2">&quot;Permutation Matrix $P$&quot;</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">],</span> <span class="n">title</span> <span class="o">=</span> <span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Column&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Row&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph-matching-vertex_17_0.png" src="../../_images/graph-matching-vertex_17_0.png" />
</div>
</div>
<p>So, looking at the permutation matrix, if we were to apply this as a row or column permutation, row/column 3 and 4 will stay the same (<span class="math notranslate nohighlight">\(p_{33} = 1\)</span> and <span class="math notranslate nohighlight">\(p_{44} = 1\)</span>, so row/column <span class="math notranslate nohighlight">\(3\)</span> and <span class="math notranslate nohighlight">\(4\)</span> will become row/column <span class="math notranslate nohighlight">\(3\)</span> and <span class="math notranslate nohighlight">\(4\)</span> respectively in the new representations), and row/column <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(2\)</span> would swap (row/column <span class="math notranslate nohighlight">\(1\)</span> would become row/column <span class="math notranslate nohighlight">\(2\)</span>, and vice versa). Let’s see what happens when we apply these sequentially:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PtD</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">D</span>
<span class="n">PtDP</span> <span class="o">=</span> <span class="n">PtD</span> <span class="o">@</span> <span class="n">P</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="mi">14</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">D</span><span class="p">,</span> <span class="n">PtD</span><span class="p">,</span> <span class="n">PtDP</span><span class="p">]</span>
<span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Original matrix $D$&quot;</span><span class="p">,</span> <span class="s2">&quot;Permutate the rows $PD$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;Permute the rows then the columns $P^\top DP$&quot;</span><span class="p">]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">],</span> <span class="n">title</span> <span class="o">=</span> <span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Column&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Row&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph-matching-vertex_20_0.png" src="../../_images/graph-matching-vertex_20_0.png" />
</div>
</div>
<p>So, we take the original matrix, and first begin by swapping rows <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(2\)</span> to give us <span class="math notranslate nohighlight">\(PD\)</span>. Next, using this row-permuted matrix, we then permute the columns by swapping columns <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(2\)</span> of <span class="math notranslate nohighlight">\(P^\top D\)</span>, to give us <span class="math notranslate nohighlight">\(P^\top DP\)</span>. This shows that by using a permutation matrix to row and then column swap, we can reorder the rows and columns of <span class="math notranslate nohighlight">\(D\)</span> simultaneously.</p>
</section>
<section id="using-concurrent-row-and-column-permutations-on-adjacency-matrices">
<h3><span class="section-number">7.3.3.4. </span>Using concurrent row and column permutations on adjacency matrices<a class="headerlink" href="#using-concurrent-row-and-column-permutations-on-adjacency-matrices" title="Permalink to this headline">#</a></h3>
<p>For our networks, remember that the adjacency matrix is the matrix <span class="math notranslate nohighlight">\(A\)</span> where the entry <span class="math notranslate nohighlight">\(a_{ij}\)</span> represents whether or not there is an edge between nodes <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>. The key aspect is that the indexing for the adjacency matrix, <span class="math notranslate nohighlight">\(ij\)</span>, is an indexing over a single set: the nodes. This means that if we want to <em>reorder</em> the adjacency matrix by moving around the nodes, we need to move both the rows <em>and</em> the columns concurrently, since the <em>node ordering</em> is what is being permuted. If we had a permutation of the nodes given by <span class="math notranslate nohighlight">\(P\)</span>, we would correspondingly reorder the adjacency matrix by permuting the rows <em>and</em> columns of <span class="math notranslate nohighlight">\(A\)</span> by using <span class="math notranslate nohighlight">\(P^\top AP\)</span>.</p>
<div class="admonition-permutation-matrices-are-unshuffled-by-their-transpose admonition">
<p class="admonition-title">Permutation Matrices are unshuffled by their transpose</p>
<p>Let’s suppose that we have a permutation matrix, <span class="math notranslate nohighlight">\(P\)</span>. We remember from above that a permutation matrix is a matrix where every row and every column has a <em>single</em> entry which takes a value of one. Let’s assume that <span class="math notranslate nohighlight">\(p_{ji} = 1\)</span>, which means that if we were to use the permutation as a row permutation, we would “flip” rows <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>, or if we were to use it as a column permutation, we would “flip” columns <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>. If we were to use it for both a row and column permutation, we would flip rows/columns <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>. How do we “undo” this operation?</p>
<p>What happens when we take the product <span class="math notranslate nohighlight">\(P^\top P\)</span>? If for any pair of indices <span class="math notranslate nohighlight">\(p_{ji} = 1\)</span>, then <span class="math notranslate nohighlight">\((P^\top)_{ij}\)</span>, the <span class="math notranslate nohighlight">\((i, j)\)</span> entry of the transpose, is also one. This is just the definition of the matrix transpose operation. What does the matrix product of <span class="math notranslate nohighlight">\(P^\top\)</span> and <span class="math notranslate nohighlight">\(P\)</span> look like? Writing out the matrix multiplication, we see:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
    P^\top P &amp;= \begin{bmatrix}
    (P^\top)_{11} &amp; ... &amp; (P^\top)_{1n} \\
    \vdots &amp; \ddots &amp; \vdots \\
    (P^\top)_{n1} &amp; ... &amp; (P^\top)_{nn}
    \end{bmatrix}\begin{bmatrix}
    p_{11} &amp; ... &amp; p_{1n} \\
    \vdots &amp; \ddots &amp; \vdots \\
    p_{n1} &amp; ... &amp; p_{nn}
    \end{bmatrix}.
\end{align*}\]</div>
<p>When we use the definition of the trampsose, this becomes:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}    P^\top P &amp;= \begin{bmatrix}
    p_{11}&amp; ... &amp; p_{n1}\\
    \vdots &amp; \ddots &amp; \vdots \\
    p_{1n} &amp; ... &amp; p_{nn}
    \end{bmatrix}\begin{bmatrix}
    p_{11} &amp; ... &amp; p_{1n} \\
    \vdots &amp; \ddots &amp; \vdots \\
    p_{n1} &amp; ... &amp; p_{nn}
    \end{bmatrix}.
\end{align*}\]</div>
<p>The resulting matrix <span class="math notranslate nohighlight">\(P^\top P\)</span> has entries <span class="math notranslate nohighlight">\(i, j\)</span> where:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
(P^\top P)_{ij} = \sum_{k = 1}^n p_{ik}p_{jk}
\end{align*}\]</div>
<p>But, as we know, for a particular row <span class="math notranslate nohighlight">\(i\)</span> and column <span class="math notranslate nohighlight">\(k\)</span>, exactly a <em>single</em> entry has a value of <span class="math notranslate nohighlight">\(1\)</span>. This means that for any <span class="math notranslate nohighlight">\(i \neq j\)</span>, that <span class="math notranslate nohighlight">\(p_{ik}p_{jk}\)</span> will <em>always</em> be equal to zero, because you could not have two rows of the same column <span class="math notranslate nohighlight">\(k\)</span> both taking the value of <span class="math notranslate nohighlight">\(1\)</span> concurrently.</p>
<p>If <span class="math notranslate nohighlight">\(i = j\)</span>, then there must be some <span class="math notranslate nohighlight">\(k\)</span> where <span class="math notranslate nohighlight">\(p_{ik} = 1\)</span>, because at least <span class="math notranslate nohighlight">\(1\)</span> entry of the columns of <span class="math notranslate nohighlight">\(P\)</span> must be <span class="math notranslate nohighlight">\(1\)</span> by definition.</p>
<p>Therefore, <span class="math notranslate nohighlight">\((P^\top P)_{ij} = 1\)</span> if <span class="math notranslate nohighlight">\(i = j\)</span>, and <span class="math notranslate nohighlight">\((P^\top P)_{ij} = 0\)</span> everywhere else. This is the definition of the identity matrix, so <span class="math notranslate nohighlight">\(P^\top P = I\)</span>. Since the transpose of the identity matrix is also the identity matrix, <span class="math notranslate nohighlight">\(PP^\top = I\)</span>, too.</p>
<p>This has the interpretation that if we permute an adjacency matrix’s rows and columns <span class="math notranslate nohighlight">\(A\)</span> with a permutation matrix <span class="math notranslate nohighlight">\(P\)</span>, giving us <span class="math notranslate nohighlight">\(B = P^\top A P\)</span>, that we can “undo” this permutation by taking <span class="math notranslate nohighlight">\(PBP^\top\)</span>. We can see this by just looking at it, and plugging in the definition of <span class="math notranslate nohighlight">\(B\)</span>:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
    PBP^\top &amp;= P\left(P^\top A P\right)P^\top, \\
    &amp;= PP^\top A PP^\top, \\
    &amp;= I A I = I
\end{align*}\]</div>
<p>where  used the fact that <span class="math notranslate nohighlight">\(PP^\top = I\)</span>.</p>
<p>In this sense, if think of <span class="math notranslate nohighlight">\(P^\top A P\)</span> being the row/column permuted adjacency matrix of <span class="math notranslate nohighlight">\(A\)</span>, then permuting it <em>again</em> with <span class="math notranslate nohighlight">\(P^\top\)</span> instead of <span class="math notranslate nohighlight">\(P\)</span> will undo the permutation.</p>
</div>
</section>
<section id="permutation-matrices-to-match-network">
<h3><span class="section-number">7.3.3.5. </span>Permutation Matrices to Match Network<a class="headerlink" href="#permutation-matrices-to-match-network" title="Permalink to this headline">#</a></h3>
<p>Next, we again consider the previous simple network example from Twitter and Facebook networks. Remember that we had two networks, where there was a node correspondance in that person <span class="math notranslate nohighlight">\(0\)</span> from Twitter was the same as person <span class="math notranslate nohighlight">\(a\)</span> from Facebook, person <span class="math notranslate nohighlight">\(1\)</span> from Twitter was the same as the person <span class="math notranslate nohighlight">\(b\)</span> from Facebook, so on and so forth.</p>
<p>We will suppose that the ordering of the nodes from Twitter are given to us in order, <span class="math notranslate nohighlight">\(\{0, 1, 2, 3\}\)</span>, so in the ideal case, if the nodes from Facebook respect the node correspondance and the nodes are ordered <span class="math notranslate nohighlight">\(\{a, b, c, d\}\)</span>, we have that:</p>
<p><img alt="gm_11" src="../../_images/gm_1.png" /></p>
<div class="math">
\[
A_T = 
\begin{array}{cc} &
\begin{array}{cccc} 0 & 1 & 2 & 3 \end{array}
\\
\begin{array}{cccc}
0 \\
1 \\
2 \\
3 \end{array}
&
\left(
\begin{array}{cccc}
0 & 1 & 1 & 0\\
1 & 0 & 0 & 1\\
1 & 0 & 0 & 1\\
0 & 1 & 1 & 0\end{array}
\right)\end{array}
\quad \quad
A_F = 
\begin{array}{cc} &
\begin{array}{cccc} a & b & c & d \end{array}
\\
\begin{array}{ccc}
a \\
b \\
c \\
d \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 1 & 0\\
1 & 0 & 0 & 1\\
1 & 0 & 0 & 1\\
0 & 1 & 1 & 0\end{array}
\right)\end{array} \\
|A_T - A_F| = \left(
\begin{array}{ccc}
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\\
0 & 0 & 0 & 0\end{array}
\right)
\]
    </div>
<p>and <span class="math notranslate nohighlight">\(f(A_T, A_F) = 0\)</span>.</p>
<p>However, if you remember, the problem was that we were <em>instead</em> given the nodes from Facebook in a different order; we were given the node ordering <span class="math notranslate nohighlight">\(\{a, b, d, c\}\)</span> with adjacency matrix <span class="math notranslate nohighlight">\(A_F'\)</span>, leading to:</p>
<div class="math">
\[
A_T = 
\begin{array}{cc} &
\begin{array}{cccc} 0 & 1 & 2 & 3 \end{array}
\\
\begin{array}{cccc}
0 \\
1 \\
2 \\
3 \end{array}
&
\left(
\begin{array}{cccc}
0 & 1 & 1 & 0\\
1 & 0 & 0 & 1\\
1 & 0 & 0 & 1\\
0 & 1 & 1 & 0\end{array}
\right)\end{array}
\quad \quad
A_F' = 
\begin{array}{cc} &
\begin{array}{cccc} a & b & d & c \end{array}
\\
\begin{array}{ccc}
a \\
b \\
d \\
c \end{array}
&
\left(
\begin{array}{ccc}
0 & 1 & 0 & 1\\
1 & 0 & 1 & 0\\
0 & 1 & 0 & 1\\
1 & 0 & 1 & 0\end{array}
\right)\end{array} \\
|A_T - A_F'| = \left(
\begin{array}{ccc}
0 & 0 & 1 & 1\\
0 & 0 & 1 & 1\\
1 & 1 & 0 & 0\\
1 & 1 & 0 & 0\end{array}
\right)
\]
    </div>
<p>and <span class="math notranslate nohighlight">\(f(A_T, A_F') = 8\)</span>. What we want to do is construct a permutation matrix <span class="math notranslate nohighlight">\(P\)</span>, which will keep nodes <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> in the same order, but swap nodes <span class="math notranslate nohighlight">\(c\)</span> and <span class="math notranslate nohighlight">\(d\)</span> in the node ordering. We can do this using exactly the strategy we developed above:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">AT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="n">AFp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>

<span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>

<span class="n">PtAFpP</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">AFp</span> <span class="o">@</span> <span class="n">P</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>

<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">AT</span><span class="p">,</span> <span class="n">AFp</span><span class="p">,</span> <span class="n">PtAFpP</span><span class="p">]</span>
<span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;$A_T$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;$A_F&#39;$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;$A_F = P^\top A_F&#39; P$&quot;</span><span class="p">]</span>

<span class="n">node_odx</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">]]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Node&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Node&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="mf">3.5</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">node_odx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">(</span><span class="n">node_odx</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph-matching-vertex_25_0.png" src="../../_images/graph-matching-vertex_25_0.png" />
</div>
</div>
<p>As shown in the code block above, using a properly chosen permutation matrix <span class="math notranslate nohighlight">\(P\)</span>, we are able to recover the node correspondance between the networks for Twitter and Facebook. We obtain that for this particular choice of <span class="math notranslate nohighlight">\(P\)</span>, that <span class="math notranslate nohighlight">\(f(A_T, P^\top A_F'P) = 0\)</span>.</p>
<p>In this way, we will use this intuition to formulate the graph matching problem. For any two adjacency matrices <span class="math notranslate nohighlight">\(A, B\)</span>, we seek to minimize the cost function <span class="math notranslate nohighlight">\(g(A,B,P) = || A - P^\top BP||_F^2\)</span> with the restriction that <span class="math notranslate nohighlight">\(P\)</span> is a permuation matrix. You will notice that this is the definition of the Frobenius norm of the difference between <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>, where you have now expanded <span class="math notranslate nohighlight">\(f\)</span> to the function <span class="math notranslate nohighlight">\(g\)</span> which includes a permutation of the rows and columns of <span class="math notranslate nohighlight">\(B\)</span>. This means that you want to figure out a way in which you can shuffle the rows and columns of <span class="math notranslate nohighlight">\(B\)</span>, such that it is as close as possible to <span class="math notranslate nohighlight">\(A\)</span>. In mathematics, the process of minimizing (or maximizing) a function based on a set of restrictions (called <em>constraints</em>) is known as <em>optimization</em>.</p>
<section id="generating-a-random-permutation-matrix">
<h4><span class="section-number">7.3.3.5.1. </span>Generating a random permutation matrix<a class="headerlink" href="#generating-a-random-permutation-matrix" title="Permalink to this headline">#</a></h4>
<p>Let’s get started with getting down in the weeds coding by making ourselves a function which creates permutation matrices. Remember that for a permutation matrix, the entry <span class="math notranslate nohighlight">\(p_{ji}\)</span> corresponds to a swap of rows/columns <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>, depending on whether it is a row or column permutation (or being used for both). The code looks like this, and we’ll explain in the comments what’s going on:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_permutation</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function that generates a permutation for n elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># the initial row/column of what is going to be permuted.</span>
    <span class="n">seed_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="c1"># the &quot;permuted&quot; row/column that the corresponding seed will </span>
    <span class="c1"># end up at</span>
    <span class="n">dest_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="c1"># initialize permutation matrix</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">))</span>
    <span class="c1"># and fill in accordingly</span>
    <span class="n">P</span><span class="p">[</span><span class="n">dest_indices</span><span class="p">,</span> <span class="n">seed_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">P</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="finding-a-good-permutation-with-gradient-descent-optimization">
<h2><span class="section-number">7.3.4. </span>Finding a good permutation with gradient descent optimization<a class="headerlink" href="#finding-a-good-permutation-with-gradient-descent-optimization" title="Permalink to this headline">#</a></h2>
<p>The algorithm used for solving graph matching optimization problem we described above is a variation of gradient descent.  The specifics of the algorithm are beyond the scope of this book, but for now you can simply imagine it as gradient descent. A gradient can be thought of as a vector valued slope; it is simply the slope of a function in all of it’s dimensions, at a single point in space. Gradient Descent is a very common optimization method using to find optimal solutions for a wide range of problems.</p>
<p>A simple way to think of the method is gravity.  Consider an inspector using a golf ball to find the lowest point when installing a drain. The ball rolls down hill until it comes to a stop; once it stops, we know we’ve found the lowest point. Gradient descent works in a similar way, taking steps in the direction of the local gradient with respect to some parameter. Once the gradient is zero, a local minimum has been found and the algorithm is stopped.</p>
<p>The main steps of a gradient descent method are choosing a suitable initial position (can be chosen randomly), then gradually improving the cost function one step at a time, until the function is changing by a very small amount, converging to a minimum. The main issue with gradient descent is that it does not guarantee that you will find a global minimum, only that you will find the local minimum of your initial position. A commonly used strategy, and the one that we employ below, is known as the Fast Approximate Quadratic (FAQ) algorithm <span id="id3">[<a class="reference internal" href="#id90" title="Joshua T. Vogelstein, John M. Conroy, Vince Lyzinski, Louis J. Podrazik, Steven G. Kratzer, Eric T. Harley, Donniell E. Fishkind, R. Jacob Vogelstein, and Carey E. Priebe. Fast Approximate Quadratic Programming for Graph Matching. PLoS One, 10(4):e0121002, April 2015. doi:10.1371/journal.pone.0121002.">2</a>]</span>.</p>
<figure class="align-center" id="grad-desc">
<img alt="../../_images/grad_desc.png" src="../../_images/grad_desc.png" />
<figcaption>
<p><span class="caption-number">Fig. 7.1 </span><span class="caption-text">Above is a simplification in two dimensions; the network functions we optimize over are n dimensional when matching networks with n nodes, making the problem incredibly difficult to solve. For this reason (among others outside of the scope of this book), the state-of-the-art graph matching algorithm is an approximation algorithm.</span><a class="headerlink" href="#grad-desc" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="graph-matching-with-graspologic">
<h2><span class="section-number">7.3.5. </span>Graph matching with graspologic<a class="headerlink" href="#graph-matching-with-graspologic" title="Permalink to this headline">#</a></h2>
<p>For the example below, we will match two networks with a known node mapping that preserves a common network structure. To do this, we simulate a single Erdos-Reyni network, <span class="math notranslate nohighlight">\(A\)</span>, with six nodes and an edge probability of 0.5. Then, we generate <span class="math notranslate nohighlight">\(B\)</span> by randomly permuting the node labels of <span class="math notranslate nohighlight">\(A\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">graspologic.simulations</span> <span class="kn">import</span> <span class="n">er_np</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">p</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">er_np</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>
<span class="c1"># make a permutation matrix</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">make_permutation</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">A</span> <span class="o">@</span> <span class="n">P</span>
<span class="n">disagreements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of adjecnecy disagreements: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements</span><span class="p">)))</span>

<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;$A$, a realization of $ER_6(0.5)$&#39;</span><span class="p">,</span> <span class="s1">&#39;$B$ ($A$ with the nodes randomly shuffled)&#39;</span><span class="p">]</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>
<span class="n">nodeAnames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)])</span>
<span class="n">nodenames</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">nodeAnames</span><span class="p">),</span> <span class="nb">list</span><span class="p">((</span><span class="n">P</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">nodeAnames</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))]</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">xticklabels</span><span class="o">=</span><span class="n">nodenames</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">],</span>
            <span class="n">yticklabels</span><span class="o">=</span><span class="n">nodenames</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Node&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Node&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of adjecnecy disagreements: 11
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_33_1.png" src="../../_images/graph-matching-vertex_33_1.png" />
</div>
</div>
<p>Below, we create a model to solve the Graph Matching Problem using the <code class="docutils literal notranslate"><span class="pre">GraphMatch</span></code> class. The model is then fit for the two networks A and B.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">graspologic.match</span> <span class="kn">import</span> <span class="n">GraphMatch</span>

<span class="n">gmp</span> <span class="o">=</span> <span class="n">GraphMatch</span><span class="p">()</span>
<span class="n">gmp</span> <span class="o">=</span> <span class="n">gmp</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Next, we can “unshuffle” the matrix by using the <code class="docutils literal notranslate"><span class="pre">gmp.perm_inds_</span></code> attribute to generate an “unshuffling” permutation matrix:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_unshuffle</span><span class="p">(</span><span class="n">dest_indices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function which creates a permutation matrix from a given permutation of the nodes.</span>
<span class="sd">    The logic is a little weird here, which is because gmp.perm_inds_ indicates the destination</span>
<span class="sd">    for each element i of B, and not A. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dest_indices</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="c1"># the seeds this time are the ordering of nodes from 1:n in B</span>
    <span class="n">seed_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="c1"># permute the shuffled indices of B to the destination specified</span>
    <span class="c1"># by the GMP</span>
    <span class="n">P</span><span class="p">[</span><span class="n">dest_indices</span><span class="p">,</span> <span class="n">seed_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">P</span>

<span class="n">P_unshuffle</span> <span class="o">=</span> <span class="n">make_unshuffle</span><span class="p">(</span><span class="n">gmp</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">)</span>

<span class="n">B_unshuffle</span> <span class="o">=</span> <span class="n">P_unshuffle</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">B</span> <span class="o">@</span> <span class="n">P_unshuffle</span>
<span class="n">disagreements_after</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B_unshuffle</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of adjacency disagreements: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements_after</span><span class="p">)))</span>


<span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;$A$&quot;</span><span class="p">,</span> <span class="s2">&quot;$B = P^</span><span class="se">\\</span><span class="s2">top A P$ ($A$ shuffled)&quot;</span><span class="p">,</span> <span class="s2">&quot;$P_u^</span><span class="se">\\</span><span class="s2">top BP_u$, $B$ with nodes unsuffled&quot;</span><span class="p">,</span> <span class="s2">&quot;$|A - P_u^</span><span class="se">\\</span><span class="s2">top BP_u|$&quot;</span><span class="p">]</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="n">nodenames</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">nodeAnames</span><span class="p">),</span> <span class="nb">list</span><span class="p">((</span><span class="n">P</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">nodeAnames</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)),</span> 
             <span class="nb">list</span><span class="p">((</span><span class="n">P_unshuffle</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">nodeAnames</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)),</span> <span class="p">[</span><span class="s2">&quot;&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nodeAnames</span><span class="p">]]</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">B_unshuffle</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B_unshuffle</span><span class="p">)]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">xticklabels</span><span class="o">=</span><span class="n">nodenames</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">],</span> <span class="n">yticklabels</span><span class="o">=</span><span class="n">nodenames</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> 
            <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Node&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Node&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of adjacency disagreements: 0
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_38_1.png" src="../../_images/graph-matching-vertex_38_1.png" />
</div>
</div>
<p>The graph matching algorithm is able to successfully unshuffle <span class="math notranslate nohighlight">\(B\)</span>, with zero adjacency disagreements between <span class="math notranslate nohighlight">\(A\)</span> and the matched <span class="math notranslate nohighlight">\(B\)</span>, using the unshuffling matrix <span class="math notranslate nohighlight">\(P_u\)</span>.</p>
<p>In this case, since <span class="math notranslate nohighlight">\(P\)</span> was the forward permutation and recovered the correct unshuffling of <span class="math notranslate nohighlight">\(B\)</span> back to <span class="math notranslate nohighlight">\(A\)</span>, <span class="math notranslate nohighlight">\(P = P_u^\top\)</span>. This is because of the fact we learned in the admonition above.</p>
<section id="the-match-ratio-of-nodes">
<h3><span class="section-number">7.3.5.1. </span>The match ratio of nodes<a class="headerlink" href="#the-match-ratio-of-nodes" title="Permalink to this headline">#</a></h3>
<p>We can evaluate the quality of an unshuffling using another metric, the <em>match ratio</em>. The <strong>match ratio</strong> is the ratio of nodes which are correctly matched. We can do this since in our simulation, we know where the nodes of <span class="math notranslate nohighlight">\(A^{(2), s}\)</span> <em>should</em> be unpermuted to. This is because by the admonition you might have read above, you know that for a permutation <span class="math notranslate nohighlight">\(P\)</span>, the corresponding un-permutation is <span class="math notranslate nohighlight">\(P^\top\)</span>, and therefore, <span class="math notranslate nohighlight">\(PP^\top = I\)</span>, the identity matrix. By a similar argument to the one we gave there, if <span class="math notranslate nohighlight">\(P_u\)</span> is the unshuffling of a permutation matrix <span class="math notranslate nohighlight">\(P\)</span>, then if the permutation is <em>correct</em>, <span class="math notranslate nohighlight">\(PP_u\)</span> should also be the identity matrix. Every node which is incorrectly matched will correspond to an entry of <span class="math notranslate nohighlight">\(0\)</span> along the diagonal of <span class="math notranslate nohighlight">\(PP_u\)</span> (or equivalently, <span class="math notranslate nohighlight">\(P_uP\)</span>). Therefore, we can just take the match ratio to be the fraction of times the diagonal of <span class="math notranslate nohighlight">\(P_uP\)</span> of <span class="math notranslate nohighlight">\(PP_u\)</span> is <span class="math notranslate nohighlight">\(1\)</span>:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
    \text{match ratio}(P, P_u) = \frac{1}{n} \sum_{i = 1}^n \mathbb I\left\{(PP_u)_{ii} = 1\right\}
\end{align*}\]</div>
<p>where <span class="math notranslate nohighlight">\(P\)</span> is a permutation matrix and <span class="math notranslate nohighlight">\(P_u\)</span> is a <em>proposed</em> unshuffling matrix. The fancy looking function <span class="math notranslate nohighlight">\(\mathbb I\{x\}\)</span> is just a counter for the number of times that the thing inside the curly braces is true. So, here, it just has a value of <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\((PP_u^\top)_{ii} = 1\)</span>, and a value of <span class="math notranslate nohighlight">\(0\)</span> if <span class="math notranslate nohighlight">\((PP_u^\top)_{ii} \neq 1\)</span>. We write a simple utility to do this, and then can call it on our permutation and un-shuffling matrix to see that the match ratio is <span class="math notranslate nohighlight">\(1\)</span> here (we perfectly unshuffled <span class="math notranslate nohighlight">\(B\)</span>):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">match_ratio</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">Pu</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># the number of nodes</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">P</span> <span class="o">@</span> <span class="n">Pu</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">/</span><span class="n">n</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;match ratio: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match_ratio</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">P_unshuffle</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>match ratio: 1.000
</pre></div>
</div>
</div>
</div>
</section>
<section id="seeds">
<h3><span class="section-number">7.3.5.2. </span>Seeds<a class="headerlink" href="#seeds" title="Permalink to this headline">#</a></h3>
<p>As mentioned previously, as networks become larger, they quickly become more difficult to match. One method to mitigate this difficulty is to use <span class="math notranslate nohighlight">\(\textit{seeds}\)</span>. Seeds are a subset of matches that we already know before we perform the graph matching. For example, if we are given two networks <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(F\)</span> with 300 nodes each, we might already know ten node matches between <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(F\)</span>. Having this prior information greatly improves our ability to match the networks.</p>
</section>
</section>
<section id="seeded-graph-matching-sgm-on-correlated-network-pairs">
<h2><span class="section-number">7.3.6. </span>Seeded Graph Matching (SGM) on Correlated Network Pairs<a class="headerlink" href="#seeded-graph-matching-sgm-on-correlated-network-pairs" title="Permalink to this headline">#</a></h2>
<p>To demonstrate the effectiveness of Seeded Graph Matching (<code class="docutils literal notranslate"><span class="pre">SGM</span></code>) <span id="id4">[<a class="reference internal" href="#id91" title="Donniell E. Fishkind, Sancar Adali, Heather G. Patsolic, Lingyao Meng, Digvijay Singh, Vince Lyzinski, and Carey E. Priebe. Seeded graph matching. Pattern Recognit., 87:203–215, March 2019. doi:10.1016/j.patcog.2018.09.014.">3</a>]</span> <span id="id5">[<a class="reference internal" href="#id92" title="V. Lyzinski, D. Fishkind, and C. Priebe. Seeded graph matching for correlated Erdös-Rényi graphs. J. Mach. Learn. Res, 2014. URL: https://www.semanticscholar.org/paper/Seeded-graph-matching-for-correlated-Erd%C3%B6s-R%C3%A9nyi-Lyzinski-Fishkind/70c25f35063b56907f0715d82ba1218362812266.">4</a>]</span>, the algorithm will be applied on a pair of correlated SBM networks (undirected, no self loops), which is a simpler adaptation of the <span class="math notranslate nohighlight">\(\rho\)</span>-correlated <span class="math notranslate nohighlight">\(RDPG\)</span> which we learned about in <a class="reference internal" href="../../representations/ch5/multi-network-models.html#ch5-multi-corr-rrdpg"><span class="std std-numref">Section 4.7.3.1</span></a>. Like the <span class="math notranslate nohighlight">\(\rho\)</span>-correlated <span class="math notranslate nohighlight">\(RDPG\)</span>, the idea here is that we have two normal SBMs, but for any edge in the two networks <span class="math notranslate nohighlight">\(\mathbf a_{ij}\)</span> and <span class="math notranslate nohighlight">\(\mathbf b_{ij}\)</span>, they will be correlated with correlation <span class="math notranslate nohighlight">\(\rho\)</span>. In words, if <span class="math notranslate nohighlight">\(\rho\)</span> is positive, then if we know that <span class="math notranslate nohighlight">\(\mathbf a_{ij}^{(1)}\)</span> has a value of one, then we have information to suggest that <span class="math notranslate nohighlight">\(\mathbf b_{ij}\)</span> might be one too. In this case, we will have that <span class="math notranslate nohighlight">\(\mathbf A\)</span> and <span class="math notranslate nohighlight">\(\mathbf B\)</span> are <span class="math notranslate nohighlight">\(\rho-SBM_n(\vec z, B)\)</span> where the networks are highly correlated, and <span class="math notranslate nohighlight">\(\rho = 0.9\)</span>. The block matrix is:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
B &amp;= \begin{bmatrix} 
0.7 &amp; 0.3 &amp; 0.4\\
0.3 &amp; 0.7 &amp; 0.3\\
0.4 &amp; 0.3 &amp; 0.7
\end{bmatrix}
\end{align*}\]</div>
<p>The first <span class="math notranslate nohighlight">\(75\)</span> nodes in the network will be from community one, the second <span class="math notranslate nohighlight">\(75\)</span> nodes in the network will be from community two, and the third <span class="math notranslate nohighlight">\(75\)</span> nodes in the network will be from community three:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">graspologic.simulations</span> <span class="kn">import</span> <span class="n">er_corr</span><span class="p">,</span> <span class="n">sbm</span><span class="p">,</span> <span class="n">sbm_corr</span>
<span class="n">directed</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">loops</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">n_per_block</span> <span class="o">=</span> <span class="mi">75</span>
<span class="n">n_blocks</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">block_members</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">n_blocks</span> <span class="o">*</span> <span class="p">[</span><span class="n">n_per_block</span><span class="p">])</span>
<span class="n">n_verts</span> <span class="o">=</span> <span class="n">block_members</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="n">rho</span> <span class="o">=</span> <span class="mf">0.9</span>
<span class="n">block_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]])</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>
<span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">sbm_corr</span><span class="p">(</span><span class="n">block_members</span><span class="p">,</span> <span class="n">block_probs</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="n">directed</span><span class="p">,</span> <span class="n">loops</span><span class="o">=</span><span class="n">loops</span><span class="p">)</span>
<span class="n">disagreements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of adjacency disagreements: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements</span><span class="p">)))</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B</span><span class="p">)]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A$&quot;</span><span class="p">,</span> <span class="s2">&quot;Network $B$&quot;</span><span class="p">,</span> <span class="s2">&quot;$|A - B|$&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of adjacency disagreements: 2236
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_45_1.png" src="../../_images/graph-matching-vertex_45_1.png" />
</div>
</div>
<p>To emphasize the effectiveness of <code class="docutils literal notranslate"><span class="pre">SGM</span></code>, as well as why having seeds is important, we will randomly shuffle the vertices of network <span class="math notranslate nohighlight">\(B\)</span>. We will call this version of <span class="math notranslate nohighlight">\(B\)</span> after shuffling <span class="math notranslate nohighlight">\(B_s\)</span>.</p>
<p>Here we see that after shuffling network <span class="math notranslate nohighlight">\(B\)</span>, there are many more edge disagreements, as expected.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">P</span> <span class="o">=</span> <span class="n">make_permutation</span><span class="p">(</span><span class="n">n_verts</span><span class="p">)</span>
<span class="c1"># shuffle A2 which is correlated to A1</span>
<span class="n">B_shuffle</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">B</span> <span class="o">@</span> <span class="n">P</span>
<span class="n">disagreements_shuffled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B_shuffle</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of adjacency disagreements: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements_shuffled</span><span class="p">)))</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B_shuffle</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B_shuffle</span><span class="p">)]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A$&quot;</span><span class="p">,</span> <span class="s2">&quot;$B_s = P^</span><span class="se">\\</span><span class="s2">top BP$, Network $B$ shuffled&quot;</span><span class="p">,</span> <span class="s2">&quot;$|A - B_s|$&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of adjacency disagreements: 25131
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_48_1.png" src="../../_images/graph-matching-vertex_48_1.png" />
</div>
</div>
<section id="matching-network-2-without-seeds">
<h3><span class="section-number">7.3.6.1. </span>matching network 2 without seeds<a class="headerlink" href="#matching-network-2-without-seeds" title="Permalink to this headline">#</a></h3>
<p>First, we will run SGM on network <span class="math notranslate nohighlight">\(A\)</span> and the shuffled network <span class="math notranslate nohighlight">\(B_s\)</span> with no seeds, using a similar approach to the above.:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># initialize sgm</span>
<span class="n">sgm</span> <span class="o">=</span> <span class="n">GraphMatch</span><span class="p">()</span>
<span class="c1"># fit with A1 and shuffled A2</span>
<span class="n">sgm</span> <span class="o">=</span> <span class="n">sgm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B_shuffle</span><span class="p">)</span>
<span class="c1"># obtain unshuffled version of the shuffled A2</span>
<span class="n">P_unshuffle_noseed</span> <span class="o">=</span> <span class="n">make_unshuffle</span><span class="p">(</span><span class="n">sgm</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">)</span>
<span class="n">B_unshuffle_noseed</span> <span class="o">=</span> <span class="n">P_unshuffle_noseed</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">B_shuffle</span> <span class="o">@</span> <span class="n">P_unshuffle_noseed</span>
<span class="c1"># compute the match ratio</span>
<span class="n">match_ratio_noseed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">P_unshuffle_noseed</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">P</span><span class="p">))</span><span class="o">/</span><span class="n">n_verts</span>
<span class="n">disagreements_noseed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B_unshuffle_noseed</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Match Ratio, no seeds: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match_ratio_noseed</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Disagreements, no seeds: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements_noseed</span><span class="p">)))</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B_unshuffle_noseed</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B_unshuffle_noseed</span><span class="p">)]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A$&quot;</span><span class="p">,</span> <span class="s2">&quot;$P_u^</span><span class="se">\\</span><span class="s2">top B_s P_u$, Network $B_s$ unshuffled&quot;</span><span class="p">,</span> <span class="s2">&quot;$|A - P_u^</span><span class="se">\\</span><span class="s2">top B_s P_u|$&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Match Ratio, no seeds: 0.004
Disagreements, no seeds: 17824
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_51_1.png" src="../../_images/graph-matching-vertex_51_1.png" />
</div>
</div>
<p>While the predicted unshuffling for <span class="math notranslate nohighlight">\(B\)</span> was relatively successful in recovering the basic structure of the network <span class="math notranslate nohighlight">\(A\)</span>, we see that the number of edge disagreements between them is still quite high, and the match ratio of successfully unshuffled nodes is quite low.</p>
</section>
<section id="unshuffling-network-2-with-10-seeds">
<h3><span class="section-number">7.3.6.2. </span>Unshuffling network 2 with 10 seeds<a class="headerlink" href="#unshuffling-network-2-with-10-seeds" title="Permalink to this headline">#</a></h3>
<p>Next, we will run SGM with 10 seeds randomly selected from the optimal permutation vector found ealier. Although 10 seeds is only about 4% of the 300 node network, we will observe below how much more accurate the matching will be compared to having no seeds. We add a little helper function, which takes a permutation matrix and a desired number of seeds, and indicates where the identified seed nodes would be permuted to:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">gen_seeds</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">n_seeds</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A function to generate n_seeds seeds for a pair of matrices A and P^TBP</span>
<span class="sd">    which are initially matched, but P has been applied to permute the nodes</span>
<span class="sd">    of B.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># obtain n_seeds random seeds from 1:n</span>
    <span class="n">seeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_seeds</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># use the permutation matrix to find where each seed was permuted to</span>
    <span class="n">seeds_permuted</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">seeds</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">seeds</span><span class="p">,</span> <span class="n">seeds_permuted</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nseeds</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># the number of seeds to use</span>
<span class="c1"># select ten nodes at random from A which will serve as seeds</span>

<span class="c1"># obtain seeds for nodes of A with nodes of B</span>
<span class="n">ref_seeds</span><span class="p">,</span> <span class="n">permuted_seeds</span> <span class="o">=</span> <span class="n">gen_seeds</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">nseeds</span><span class="p">)</span>

<span class="c1"># generate sgm instance</span>
<span class="n">sgm</span> <span class="o">=</span> <span class="n">GraphMatch</span><span class="p">()</span>
<span class="c1"># run SGM with A and shuffled B, but provide the seed nodes from A as ref_seeds</span>
<span class="c1"># and the corresponding position of these seed nodes after shuffling as permuted_seeds</span>
<span class="n">sgm</span> <span class="o">=</span> <span class="n">sgm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B_shuffle</span><span class="p">,</span> <span class="n">ref_seeds</span><span class="p">,</span> <span class="n">permuted_seeds</span><span class="p">)</span>
<span class="n">P_unshuffle_seeds</span> <span class="o">=</span> <span class="n">make_unshuffle</span><span class="p">(</span><span class="n">sgm</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">)</span>

<span class="n">B_unshuffle_seeds</span> <span class="o">=</span> <span class="n">P_unshuffle_seeds</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">B_shuffle</span> <span class="o">@</span> <span class="n">P_unshuffle_seeds</span>

<span class="n">match_ratio_seeds</span> <span class="o">=</span> <span class="n">match_ratio</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">P_unshuffle_seeds</span><span class="p">)</span>
<span class="n">disagreements_seeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B_unshuffle_seeds</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Match Ratio with seeds: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match_ratio_seeds</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Disagreements with seeds: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements_seeds</span><span class="p">)))</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B_unshuffle_seeds</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B_unshuffle_seeds</span><span class="p">)]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A$&quot;</span><span class="p">,</span> <span class="s2">&quot;$P_u^</span><span class="se">\\</span><span class="s2">top B_s P_u$, Network $B_s$ unshuffled&quot;</span><span class="p">,</span> <span class="s2">&quot;$|A - P_u^</span><span class="se">\\</span><span class="s2">top B P_u|$&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Match Ratio with seeds: 1.000
Disagreements with seeds: 2236
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_56_1.png" src="../../_images/graph-matching-vertex_56_1.png" />
</div>
</div>
<p>From the results above, we see that when running SGM on the same two networks, with no seeds there is match ratio is quite low. However including 10 seeds increases the match ratio to 100% (meaning that the shuffled <span class="math notranslate nohighlight">\(B_s\)</span>, <span class="math notranslate nohighlight">\(P^\top B P\)</span>, was completely correctly unshuffled using <span class="math notranslate nohighlight">\(P_u\)</span>).</p>
</section>
</section>
<section id="what-happens-when-the-number-of-nodes-aren-t-the-same">
<h2><span class="section-number">7.3.7. </span>What happens when the number of nodes aren’t the same?<a class="headerlink" href="#what-happens-when-the-number-of-nodes-aren-t-the-same" title="Permalink to this headline">#</a></h2>
<p>From what we’ve seen so far, the two networks you are interested in matching nodes for must have the same number of nodes. In practice, this is a pretty restrictive limitation! You will often come across pairs of networks where many, if not all, of the nodes in the smaller network are matched to a node in the larger network. In this case, you have a dilemma: how do you match the nodes between the networks, but you don’t know what to do with the extra nodes in the larger network. We will do this through a technique called <strong>padded graph matching</strong>, in which we add <em>isolated nodes</em> to the smaller network until it has the same number of nodes as the bigger network, and then we run graph matching on the resulting networks with an equal number of nodes. We have two techniques to add these isolated nodes, naive and adaptive padding.</p>
<p>For these examples, we’ll adjust our example slightly. We’ll keep our first network <span class="math notranslate nohighlight">\(A\)</span> exactly like the network we sampled above from the <span class="math notranslate nohighlight">\(\rho\)</span>-SBM. For <span class="math notranslate nohighlight">\(B\)</span>, we’ll arbitrarily take out the last 35 nodes of each block:</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nremove</span> <span class="o">=</span> <span class="mi">35</span>

<span class="c1"># nodes to retain from A</span>
<span class="c1"># note: nodes_to_retain is a the mapping from</span>
<span class="c1"># the nodes in Brem to the nodes in B</span>
<span class="n">n_verts_B</span> <span class="o">=</span> <span class="n">n_verts</span> <span class="o">-</span> <span class="n">nremove</span><span class="o">*</span><span class="n">n_blocks</span>
<span class="n">nodes_to_retain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">n_per_block</span> <span class="o">-</span> <span class="n">nremove</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">75</span><span class="p">,</span> <span class="mi">150</span><span class="p">]]</span>
<span class="p">)</span>
<span class="n">B_rem</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">nodes_to_retain</span><span class="p">,:][:,</span><span class="n">nodes_to_retain</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">B_rem</span><span class="p">]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A$&quot;</span><span class="p">,</span> <span class="s2">&quot;Network $B$, no nodes removed&quot;</span><span class="p">,</span> <span class="s2">&quot;Network $B_r$, $B$ with 35 nodes removed per-block&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph-matching-vertex_59_0.png" src="../../_images/graph-matching-vertex_59_0.png" />
</div>
</div>
<p>which leaves us with a network <span class="math notranslate nohighlight">\(B_r\)</span> and corresponding underlying random network <span class="math notranslate nohighlight">\(\mathbf B_r\)</span> in which there are only <span class="math notranslate nohighlight">\(120\)</span> instead of <span class="math notranslate nohighlight">\(225\)</span> nodes. These <span class="math notranslate nohighlight">\(150\)</span> nodes are matched to <span class="math notranslate nohighlight">\(150\)</span> of the <span class="math notranslate nohighlight">\(225\)</span> nodes in <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(\mathbf A\)</span>, respectively. We won’t shuffle <span class="math notranslate nohighlight">\(B_r\)</span> this time, but you can trust us these techniques work if your network is shuffled, too!</p>
<p>Your task is to match the <span class="math notranslate nohighlight">\(150\)</span> nodes in <span class="math notranslate nohighlight">\(B_r\)</span> to their corresponding matched pair in <span class="math notranslate nohighlight">\(A\)</span>.</p>
<p>Behind the scenes, what you want to do is basically take the network <span class="math notranslate nohighlight">\(A\)</span>, and match <span class="math notranslate nohighlight">\(B\)</span> to a <em>subnetwork</em> of <span class="math notranslate nohighlight">\(A\)</span> which is <em>induced</em> by the nodes for which there is a corresponding matched pair. By this, what we mean is that we want to figure out which nodes in the larger network <span class="math notranslate nohighlight">\(A\)</span> <em>actually have</em> a matched pair in <span class="math notranslate nohighlight">\(B_r\)</span>, and virtually <em>ignore</em> the other nodes entirely! In this case, the induced subnetwork of <span class="math notranslate nohighlight">\(A\)</span> looks like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A_induced</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">nodes_to_retain</span><span class="p">,:][:,</span><span class="n">nodes_to_retain</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">A_induced</span><span class="p">]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A$&quot;</span><span class="p">,</span> <span class="s2">&quot;Induced Subnetwork of $A$&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph-matching-vertex_63_0.png" src="../../_images/graph-matching-vertex_63_0.png" />
</div>
</div>
<section id="naive-padded-graph-matching">
<h3><span class="section-number">7.3.7.1. </span>Naive Padded Graph Matching<a class="headerlink" href="#naive-padded-graph-matching" title="Permalink to this headline">#</a></h3>
<p>Through naive padding, you simply add <em>isolated</em> nodes (if you remember from <a class="reference internal" href="../../representations/ch4/regularization.html#ch4-regularization"><span class="std std-numref">Section 3.4</span></a>, <em>isolated</em> nodes in a simple network are just nodes which do not have any edges in the network) to the smaller network (which is <span class="math notranslate nohighlight">\(B\)</span>, in your case), until the number of nodes in <span class="math notranslate nohighlight">\(B\)</span> are equal to the number of nodes in <span class="math notranslate nohighlight">\(A\)</span>. The padded version of <span class="math notranslate nohighlight">\(B\)</span> looks like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">B_padded</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">B_rem</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="n">nremove</span><span class="o">*</span><span class="n">n_blocks</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nremove</span><span class="o">*</span><span class="n">n_blocks</span><span class="p">)])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">B_rem</span><span class="p">,</span> <span class="n">B_padded</span><span class="p">]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $B_r$, $B$ with 35 nodes removed per-block&quot;</span><span class="p">,</span> <span class="s2">&quot;$B_p$, Network $B_r$ after padding&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/graph-matching-vertex_66_0.png" src="../../_images/graph-matching-vertex_66_0.png" />
</div>
</div>
<p>Which makes the number of nodes in <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B_r\)</span> the same:</p>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Number of nodes in B, padded: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">B_padded</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Number of nodes in B, padded: 225
</pre></div>
</div>
</div>
</div>
<p>You specify this by instantiating a <code class="docutils literal notranslate"><span class="pre">GraphMatch</span></code> object, using the argument, <code class="docutils literal notranslate"><span class="pre">padding=&quot;naive&quot;</span></code>. Then, you re-run graph matching, optionally, using seeding, just like you did before. In our “seed generator” we built above, notice that we left an option to specify the elements we choose from manually (and not just <span class="math notranslate nohighlight">\(1:n\)</span>), by specifying the <span class="math notranslate nohighlight">\(n\)</span> argument directly:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nseeds_padded</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">gmp_naive</span> <span class="o">=</span> <span class="n">GraphMatch</span><span class="p">(</span><span class="n">padding</span><span class="o">=</span><span class="s2">&quot;naive&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span>
<span class="c1"># obtain which nodes of B will be the seeds to use</span>
<span class="n">rem_seeds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">n_verts_B</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">nseeds_padded</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># obtain seeds in A which are the indices of the retained nodes</span>
<span class="c1"># of the corresponding seeds in B</span>
<span class="n">ref_seeds</span> <span class="o">=</span> <span class="n">nodes_to_retain</span><span class="p">[</span><span class="n">rem_seeds</span><span class="p">]</span>

<span class="c1"># run SGM with A1 and A2 with nodes removed</span>
<span class="c1"># since we didn&#39;t shuffle A2, the seeds are the same for both</span>
<span class="n">gmp_naive</span> <span class="o">=</span> <span class="n">gmp_naive</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B_rem</span><span class="p">,</span> <span class="n">ref_seeds</span><span class="p">,</span> <span class="n">rem_seeds</span><span class="p">)</span>

<span class="c1"># unshuffle B using the padded version of B and the permutation identified</span>
<span class="n">P_unshuffle</span> <span class="o">=</span> <span class="n">make_unshuffle</span><span class="p">(</span><span class="n">gmp_naive</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">)</span>
<span class="n">B_unshuffle_seeds_naive</span> <span class="o">=</span> <span class="n">P_unshuffle</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">B_padded</span> <span class="o">@</span> <span class="n">P_unshuffle</span>

<span class="n">naive_matching</span> <span class="o">=</span> <span class="n">gmp_naive</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">[</span><span class="n">nodes_to_retain</span><span class="p">]</span>
<span class="n">match_ratio_naive</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">naive_matching</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_verts_B</span><span class="p">))</span>
<span class="n">disagreements_naive</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B_unshuffle_seeds_naive</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Match Ratio, naive padding: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match_ratio_naive</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Disagreements, naive padding: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements_naive</span><span class="p">)))</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B_padded</span><span class="p">,</span> <span class="n">B_unshuffle_seeds_naive</span><span class="p">]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A$&quot;</span><span class="p">,</span> <span class="s2">&quot;$B_p$, Network $B_r$ after padding&quot;</span><span class="p">,</span> <span class="s2">&quot;$P_u^</span><span class="se">\\</span><span class="s2">top B_p P_u$, Network $B_r$ naive matched&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Match Ratio, naive padding: 0.083
Disagreements, naive padding: 19567
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_71_1.png" src="../../_images/graph-matching-vertex_71_1.png" />
</div>
</div>
<p>We have managed to match some of the nodes, but the match ratio is still very low, and the number of disagreements is very high. The naive matching of <span class="math notranslate nohighlight">\(B\)</span> after padding looks nothing like <span class="math notranslate nohighlight">\(A\)</span> we were trying to match it to. What happened?</p>
</section>
<section id="adopted-padded-graph-matching">
<h3><span class="section-number">7.3.7.2. </span>Adopted Padded Graph Matching<a class="headerlink" href="#adopted-padded-graph-matching" title="Permalink to this headline">#</a></h3>
<p>As it turns out, when we use this naive approach for padded graph matching, we matched <span class="math notranslate nohighlight">\(B\)</span> with the best <em>subnetwork</em> of <span class="math notranslate nohighlight">\(A\)</span>. In practice, what this means is that we took the isolated nodes of <span class="math notranslate nohighlight">\(B\)</span> that we added (just to make the number of nodes align) and attempted to find signal in these nodes. These nodes then, in effect, ended up being aligned to low-density subnetworks of <span class="math notranslate nohighlight">\(A\)</span>, which means that we allowed nodes that didn’t really exist in <span class="math notranslate nohighlight">\(B\)</span> to still have an impact on the matching quality!</p>
<p>Instead, what we want to do is match <span class="math notranslate nohighlight">\(B\)</span> to the best fitting <em>induced subnetwork</em> of <span class="math notranslate nohighlight">\(A\)</span>. The key difference is that, the ideal case, the subnetwork <em>induced</em> on <span class="math notranslate nohighlight">\(A\)</span> is the subnetwork induced by the set of nodes which were <em>actually</em> retained by <span class="math notranslate nohighlight">\(B\)</span>, and <em>not</em> just any old subnetwork.</p>
<p>To do this, we use a strategy called <em>adopted padding</em>, which is performed using <code class="docutils literal notranslate"><span class="pre">padding=&quot;adopted&quot;</span></code> for the <code class="docutils literal notranslate"><span class="pre">GraphMatch</span></code> object. Through adoptive padding, we instead perform graph matching between <span class="math notranslate nohighlight">\(\tilde A\)</span> and a padded version of <span class="math notranslate nohighlight">\(\tilde B\)</span>, where <span class="math notranslate nohighlight">\(\tilde A = 2A\)</span> minus a matrix of ones, and vice-versa for <span class="math notranslate nohighlight">\(\tilde B\)</span>. We again pad <span class="math notranslate nohighlight">\(\tilde B\)</span> exactly like we did before. What this has the effect of is making it so we will <em>discount</em> the padded nodes entirely when performing our graph matching, and will allow us to find the best induced subnetwork instead. We perform this as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">gmp_adopted</span> <span class="o">=</span> <span class="n">GraphMatch</span><span class="p">(</span><span class="n">padding</span><span class="o">=</span><span class="s2">&quot;adopted&quot;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span>

<span class="c1"># run SGM with A and B with nodes removed</span>
<span class="c1"># since we didn&#39;t shuffle B, the seeds are the same for both</span>
<span class="n">gmp_adopted</span> <span class="o">=</span> <span class="n">gmp_adopted</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B_rem</span><span class="p">,</span> <span class="n">ref_seeds</span><span class="p">,</span> <span class="n">rem_seeds</span><span class="p">)</span>

<span class="c1"># unshuffle B using the padded version of B and the permutation identified</span>
<span class="n">P_unshuffle</span> <span class="o">=</span> <span class="n">make_unshuffle</span><span class="p">(</span><span class="n">gmp_adopted</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">)</span>
<span class="n">B_unshuffle_seeds_adopted</span> <span class="o">=</span> <span class="n">P_unshuffle</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">B_padded</span> <span class="o">@</span> <span class="n">P_unshuffle</span>

<span class="n">adopted_matching</span> <span class="o">=</span> <span class="n">gmp_adopted</span><span class="o">.</span><span class="n">perm_inds_</span><span class="p">[</span><span class="n">nodes_to_retain</span><span class="p">]</span>
<span class="n">match_ratio_adopted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">adopted_matching</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_verts_B</span><span class="p">))</span>
<span class="n">disagreements_adopted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">B_unshuffle_seeds_adopted</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Match Ratio, adopted padding: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match_ratio_adopted</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Disagreements, adopted padding: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements_adopted</span><span class="p">)))</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B_padded</span><span class="p">,</span> <span class="n">B_unshuffle_seeds_adopted</span><span class="p">]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A$&quot;</span><span class="p">,</span> <span class="s2">&quot;Network $B_r$ after padding&quot;</span><span class="p">,</span> <span class="s2">&quot;$P_u^</span><span class="se">\\</span><span class="s2">top B_r P_u$, Network $B_r$ adopted matched&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Match Ratio, adopted padding: 0.225
Disagreements, adopted padding: 20580
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_75_1.png" src="../../_images/graph-matching-vertex_75_1.png" />
</div>
</div>
<p>Using adopted matching has increased the match ratio to perfect, but the number of disagreements is <em>still</em> pretty high!</p>
<p>As it turns out, since we have isolated nodes in the network, a better way to view this comparison would be to look at <span class="math notranslate nohighlight">\(A\)</span> on the <em>subnetwork induced</em> by the non-isolated nodes of <span class="math notranslate nohighlight">\(B\)</span>, and compute the number of disagreements here instead:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nonisolates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">B_unshuffle_seeds_adopted</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">A_ind_by_nonisolates</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">nonisolates</span><span class="p">,:][:,</span><span class="n">nonisolates</span><span class="p">]</span>
<span class="n">B_ind_by_nonis_unshuf</span> <span class="o">=</span> <span class="n">B_unshuffle_seeds_adopted</span><span class="p">[</span><span class="n">nonisolates</span><span class="p">,:][:,</span><span class="n">nonisolates</span><span class="p">]</span>

<span class="n">disagreements_naive_nonisolates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">A_ind_by_nonisolates</span> <span class="o">-</span> <span class="n">B_ind_by_nonis_unshuf</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Match Ratio, adopted padding: </span><span class="si">{:.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">match_ratio_adopted</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Disagreements, adoptive padding, non-isolates: </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">disagreements_naive_nonisolates</span><span class="p">)))</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">mtxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">A_ind_by_nonisolates</span><span class="p">,</span> <span class="n">B_ind_by_nonis_unshuf</span><span class="p">]</span>
<span class="n">titles</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Network $A$&quot;</span><span class="p">,</span> <span class="s2">&quot;Network $A$, isolates of $B$ removed&quot;</span><span class="p">,</span> <span class="s2">&quot;Network $B$, adopted match&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axs</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
    <span class="n">heatmap</span><span class="p">(</span><span class="n">mtxs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="n">cbar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">titles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmaps</span><span class="p">[</span><span class="s2">&quot;sequential&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Match Ratio, adopted padding: 0.225
Disagreements, adoptive padding, non-isolates: 4102
</pre></div>
</div>
<img alt="../../_images/graph-matching-vertex_79_1.png" src="../../_images/graph-matching-vertex_79_1.png" />
</div>
</div>
<p>Which is much more reasonable, as it excludes the isolated nodes (which were only added so the number of nodes aligned, and were in effect, “dummy nodes”) from the disagreement computation.</p>
</section>
</section>
<section id="references">
<h2><span class="section-number">7.3.8. </span>References<a class="headerlink" href="#references" title="Permalink to this headline">#</a></h2>
<div class="docutils container" id="id6">
<dl class="citation">
<dt class="label" id="id89"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>Lorenzo Livi and Antonello Rizzi. The graph matching problem. <em>Pattern Anal. Appl.</em>, 16(3):253–283, August 2013. <a class="reference external" href="https://doi.org/10.1007/s10044-012-0284-8">doi:10.1007/s10044-012-0284-8</a>.</p>
</dd>
<dt class="label" id="id90"><span class="brackets"><a class="fn-backref" href="#id3">2</a></span></dt>
<dd><p>Joshua T. Vogelstein, John M. Conroy, Vince Lyzinski, Louis J. Podrazik, Steven G. Kratzer, Eric T. Harley, Donniell E. Fishkind, R. Jacob Vogelstein, and Carey E. Priebe. Fast Approximate Quadratic Programming for Graph Matching. <em>PLoS One</em>, 10(4):e0121002, April 2015. <a class="reference external" href="https://doi.org/10.1371/journal.pone.0121002">doi:10.1371/journal.pone.0121002</a>.</p>
</dd>
<dt class="label" id="id91"><span class="brackets"><a class="fn-backref" href="#id4">3</a></span></dt>
<dd><p>Donniell E. Fishkind, Sancar Adali, Heather G. Patsolic, Lingyao Meng, Digvijay Singh, Vince Lyzinski, and Carey E. Priebe. Seeded graph matching. <em>Pattern Recognit.</em>, 87:203–215, March 2019. <a class="reference external" href="https://doi.org/10.1016/j.patcog.2018.09.014">doi:10.1016/j.patcog.2018.09.014</a>.</p>
</dd>
<dt class="label" id="id92"><span class="brackets"><a class="fn-backref" href="#id5">4</a></span></dt>
<dd><p>V. Lyzinski, D. Fishkind, and C. Priebe. Seeded graph matching for correlated Erdös-Rényi graphs. <em>J. Mach. Learn. Res</em>, 2014. URL: <a class="reference external" href="https://www.semanticscholar.org/paper/Seeded-graph-matching-for-correlated-Erd%C3%B6s-R%C3%A9nyi-Lyzinski-Fishkind/70c25f35063b56907f0715d82ba1218362812266">https://www.semanticscholar.org/paper/Seeded-graph-matching-for-correlated-Erd%C3%B6s-R%C3%A9nyi-Lyzinski-Fishkind/70c25f35063b56907f0715d82ba1218362812266</a>.</p>
</dd>
</dl>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./applications/ch8"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="significant-communities.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">7.2. </span>Two-sample hypothesis testing in SBMs</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="multiple-vertex-nomination.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">7.4. </span>Vertex Nomination For Two Networks</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Eric Bridgeford, Alex Loftus, and Joshua Vogelstein<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>